-- Run by onlyonestands

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/imcomingforyou6959-gif/Mitro/refs/heads/main/virtual"))()

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- Settings table
local Settings = {
    Aimbot = {
        Enabled = false,
        Smoothness = 0.5,
        FOV = 90,
        TeamCheck = true,
        VisibleCheck = true,
        TargetPart = "Head",
        Prediction = 0.1,
        PredictionType = "Linear", -- Linear, Velocity, Acceleration
        ShowFOV = true,
        FOVColor = Color3.fromRGB(255, 255, 255),
        FOVAlpha = 0.5,
        LockKey = Enum.UserInputType.MouseButton2, -- Right click default
        LockMode = "Hold", -- Hold, Toggle
        Locked = false,
        CurrentTarget = nil,
        SilentAim = false,
        Wallbang = false,
        AutoShoot = false,
        AutoPrediction = true
    },
    ESP = {
        Enabled = false,
        Boxes = true,
        Names = true,
        Health = true,
        Distance = true,
        TeamCheck = true,
        Tracers = false,
        Chams = false,
        Snaplines = false,
        BoxColor = Color3.fromRGB(255, 0, 0),
        TracerColor = Color3.fromRGB(255, 255, 255),
        TextColor = Color3.fromRGB(255, 255, 255),
        HealthColor = Color3.fromRGB(0, 255, 0),
        BoxOutline = true,
        BoxCorner = false
    },
    Misc = {
        TeamCheck = true,
        Crosshair = false,
        CrosshairColor = Color3.fromRGB(255, 255, 255),
        CrosshairSize = 10,
        CrosshairGap = 0,
        CrosshairThickness = 2,
        FOVCircle = false,
        FOVCircleColor = Color3.fromRGB(255, 255, 255),
        FOVCircleAlpha = 0.5,
        FOVRadius = 100,
        Hitmarker = false,
        HitmarkerSound = false,
        BHop = false,
        NoClip = false,
        Walkspeed = 16,
        JumpPower = 50
    },
    Targets = {
        Priority = {}, -- Priority targets
        Ignore = {}, -- Ignore targets
        WallbangMaterial = {"Glass", "Wood", "Plastic"}
    }
}

-- Create the main window
local Window = Library:Window({
    Name = "Universal Script | aqua",
    Size = UDim2.new(0, 751, 0, 539)
})

-- Watermark
local Watermark = Library:Watermark("aqua v2")

-- Keybind list
local KeybindList = Library:KeybindList()

-- Create pages
local AimbotPage = Window:Page({Name = "Aimbot", Columns = 2})
local ESPPage = Window:Page({Name = "ESP", Columns = 2})
local VisualsPage = Window:Page({Name = "Visuals", Columns = 2})
local MiscPage = Window:Page({Name = "Misc", Columns = 2})
local SettingsPage = Window:Page({Name = "Settings", Columns = 2})

--[[ AIMBOT PAGE ]]--

-- Aimbot Main Section (Side 1)
local AimbotMain = AimbotPage:Section({Name = "Main Settings", Side = 1})

local AimbotToggle = AimbotMain:Toggle({
    Name = "Enable Aimbot",
    Flag = "AimbotEnabled",
    Default = false,
    Callback = function(value)
        Settings.Aimbot.Enabled = value
    end
})

local SilentAimToggle = AimbotMain:Toggle({
    Name = "Silent Aim",
    Flag = "SilentAim",
    Default = false,
    Callback = function(value)
        Settings.Aimbot.SilentAim = value
    end
})

local AutoShootToggle = AimbotMain:Toggle({
    Name = "Auto Shoot",
    Flag = "AutoShoot",
    Default = false,
    Callback = function(value)
        Settings.Aimbot.AutoShoot = value
    end
})

local WallbangToggle = AimbotMain:Toggle({
    Name = "Wallbang",
    Flag = "Wallbang",
    Default = false,
    Callback = function(value)
        Settings.Aimbot.Wallbang = value
    end
})

local AimbotSmoothness = AimbotMain:Slider({
    Name = "Smoothness",
    Flag = "AimbotSmoothness",
    Min = 0.1,
    Max = 1,
    Decimals = 0.01,
    Suffix = "",
    Default = 0.5,
    Callback = function(value)
        Settings.Aimbot.Smoothness = value
    end
})

local AimbotFOV = AimbotMain:Slider({
    Name = "FOV Size",
    Flag = "AimbotFOV",
    Min = 10,
    Max = 360,
    Decimals = 0,
    Suffix = "Â°",
    Default = 90,
    Callback = function(value)
        Settings.Aimbot.FOV = value
    end
})

-- Aimbot Prediction Section (Side 1)
local PredictionSection = AimbotPage:Section({Name = "Prediction", Side = 1})

local PredictionType = PredictionSection:Dropdown({
    Name = "Prediction Type",
    Flag = "PredictionType",
    Items = {"Linear", "Velocity", "Acceleration", "Advanced"},
    Default = "Linear",
    Multi = false,
    Callback = function(value)
        Settings.Aimbot.PredictionType = value
    end
})

local AimbotPrediction = PredictionSection:Slider({
    Name = "Prediction Amount",
    Flag = "AimbotPrediction",
    Min = 0,
    Max = 1,
    Decimals = 0.01,
    Suffix = "s",
    Default = 0.1,
    Callback = function(value)
        Settings.Aimbot.Prediction = value
    end
})

local AutoPredictionToggle = PredictionSection:Toggle({
    Name = "Auto Prediction",
    Flag = "AutoPrediction",
    Default = true,
    Callback = function(value)
        Settings.Aimbot.AutoPrediction = value
    end
})

-- Aimbot Target Section (Side 2)
local AimbotTarget = AimbotPage:Section({Name = "Target Settings", Side = 2})

local TeamCheckToggle = AimbotTarget:Toggle({
    Name = "Team Check",
    Flag = "AimbotTeamCheck",
    Default = true,
    Callback = function(value)
        Settings.Aimbot.TeamCheck = value
    end
})

local VisibleCheckToggle = AimbotTarget:Toggle({
    Name = "Visible Check",
    Flag = "AimbotVisibleCheck",
    Default = true,
    Callback = function(value)
        Settings.Aimbot.VisibleCheck = value
    end
})

local ShowFOVToggle = AimbotTarget:Toggle({
    Name = "Show FOV Circle",
    Flag = "AimbotShowFOV",
    Default = true,
    Callback = function(value)
        Settings.Aimbot.ShowFOV = value
    end
})

local TargetPartDropdown = AimbotTarget:Dropdown({
    Name = "Target Part",
    Flag = "AimbotTargetPart",
    Items = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", "Nearest"},
    Default = "Head",
    Multi = false,
    Callback = function(value)
        Settings.Aimbot.TargetPart = value
    end
})

-- Keybind Section (Side 2)
local KeybindSection = AimbotPage:Section({Name = "Keybinds", Side = 2})

local AimbotKeybind = KeybindSection:Label("Aimbot Key"):Keybind({
    Name = "AimbotKey",
    Flag = "AimbotKey",
    Default = Enum.UserInputType.MouseButton2,
    Mode = "Hold",
    Callback = function(value)
        Settings.Aimbot.LockKey = value
    end
})

local FOVColorPicker = KeybindSection:Label("FOV Color"):Colorpicker({
    Flag = "AimbotFOVColor",
    Default = Color3.fromRGB(255, 255, 255),
    Alpha = 0.5,
    Callback = function(color, alpha)
        Settings.Aimbot.FOVColor = color
        Settings.Aimbot.FOVAlpha = alpha
    end
})

--[[ ESP PAGE ]]--

-- ESP Main Section (Side 1)
local ESPMain = ESPPage:Section({Name = "ESP Settings", Side = 1})

local ESPToggle = ESPMain:Toggle({
    Name = "Enable ESP",
    Flag = "ESPEnabled",
    Default = false,
    Callback = function(value)
        Settings.ESP.Enabled = value
    end
})

local ESPBoxesToggle = ESPMain:Toggle({
    Name = "Boxes",
    Flag = "ESPBoxes",
    Default = true,
    Callback = function(value)
        Settings.ESP.Boxes = value
    end
})

local ESPBoxOutlineToggle = ESPMain:Toggle({
    Name = "Box Outline",
    Flag = "ESPBoxOutline",
    Default = true,
    Callback = function(value)
        Settings.ESP.BoxOutline = value
    end
})

local ESPBoxCornerToggle = ESPMain:Toggle({
    Name = "Corner Boxes",
    Flag = "ESPBoxCorner",
    Default = false,
    Callback = function(value)
        Settings.ESP.BoxCorner = value
    end
})

local ESPNamesToggle = ESPMain:Toggle({
    Name = "Names",
    Flag = "ESPNames",
    Default = true,
    Callback = function(value)
        Settings.ESP.Names = value
    end
})

local ESPHealthToggle = ESPMain:Toggle({
    Name = "Health",
    Flag = "ESPHealth",
    Default = true,
    Callback = function(value)
        Settings.ESP.Health = value
    end
})

local ESPDistanceToggle = ESPMain:Toggle({
    Name = "Distance",
    Flag = "ESPDistance",
    Default = true,
    Callback = function(value)
        Settings.ESP.Distance = value
    end
})

local ESPTracersToggle = ESPMain:Toggle({
    Name = "Tracers",
    Flag = "ESPTracers",
    Default = false,
    Callback = function(value)
        Settings.ESP.Tracers = value
    end
})

local ESPSnaplinesToggle = ESPMain:Toggle({
    Name = "Snaplines",
    Flag = "ESPSnaplines",
    Default = false,
    Callback = function(value)
        Settings.ESP.Snaplines = value
    end
})

local ESPChamsToggle = ESPMain:Toggle({
    Name = "Chams",
    Flag = "ESPChams",
    Default = false,
    Callback = function(value)
        Settings.ESP.Chams = value
    end
})

local ESPTeamCheckToggle = ESPMain:Toggle({
    Name = "Team Check",
    Flag = "ESPTeamCheck",
    Default = true,
    Callback = function(value)
        Settings.ESP.TeamCheck = value
    end
})

-- ESP Colors Section (Side 2)
local ESPColorSection = ESPPage:Section({Name = "Colors", Side = 2})

local ESPBoxColor = ESPColorSection:Label("Box Color"):Colorpicker({
    Flag = "ESPBoxColor",
    Default = Color3.fromRGB(255, 0, 0),
    Alpha = 1,
    Callback = function(color)
        Settings.ESP.BoxColor = color
    end
})

local ESPTextColor = ESPColorSection:Label("Text Color"):Colorpicker({
    Flag = "ESPTextColor",
    Default = Color3.fromRGB(255, 255, 255),
    Alpha = 1,
    Callback = function(color)
        Settings.ESP.TextColor = color
    end
})

local ESPHealthColor = ESPColorSection:Label("Health Color"):Colorpicker({
    Flag = "ESPHealthColor",
    Default = Color3.fromRGB(0, 255, 0),
    Alpha = 1,
    Callback = function(color)
        Settings.ESP.HealthColor = color
    end
})

local ESPTracerColor = ESPColorSection:Label("Tracer Color"):Colorpicker({
    Flag = "ESPTracerColor",
    Default = Color3.fromRGB(255, 255, 255),
    Alpha = 1,
    Callback = function(color)
        Settings.ESP.TracerColor = color
    end
})

--[[ VISUALS PAGE ]]--

local VisualsSection = VisualsPage:Section({Name = "Visuals", Side = 1})

local CrosshairToggle = VisualsSection:Toggle({
    Name = "Crosshair",
    Flag = "Crosshair",
    Default = false,
    Callback = function(value)
        Settings.Misc.Crosshair = value
    end
})

local CrosshairColor = VisualsSection:Label("Crosshair Color"):Colorpicker({
    Flag = "CrosshairColor",
    Default = Color3.fromRGB(255, 255, 255),
    Alpha = 1,
    Callback = function(color)
        Settings.Misc.CrosshairColor = color
    end
})

local CrosshairSize = VisualsSection:Slider({
    Name = "Crosshair Size",
    Flag = "CrosshairSize",
    Min = 5,
    Max = 30,
    Decimals = 0,
    Suffix = "px",
    Default = 10,
    Callback = function(value)
        Settings.Misc.CrosshairSize = value
    end
})

local CrosshairGap = VisualsSection:Slider({
    Name = "Crosshair Gap",
    Flag = "CrosshairGap",
    Min = 0,
    Max = 20,
    Decimals = 0,
    Suffix = "px",
    Default = 0,
    Callback = function(value)
        Settings.Misc.CrosshairGap = value
    end
})

local CrosshairThickness = VisualsSection:Slider({
    Name = "Crosshair Thickness",
    Flag = "CrosshairThickness",
    Min = 1,
    Max = 5,
    Decimals = 0,
    Suffix = "",
    Default = 2,
    Callback = function(value)
        Settings.Misc.CrosshairThickness = value
    end
})

local FOVCircleToggle = VisualsSection:Toggle({
    Name = "FOV Circle",
    Flag = "FOVCircle",
    Default = false,
    Callback = function(value)
        Settings.Misc.FOVCircle = value
    end
})

local FOVCircleRadius = VisualsSection:Slider({
    Name = "FOV Radius",
    Flag = "FOVRadius",
    Min = 50,
    Max = 500,
    Decimals = 0,
    Suffix = "px",
    Default = 100,
    Callback = function(value)
        Settings.Misc.FOVRadius = value
    end
})

local FOVCircleColor = VisualsSection:Label("FOV Circle Color"):Colorpicker({
    Flag = "FOVCircleColor",
    Default = Color3.fromRGB(255, 255, 255),
    Alpha = 0.5,
    Callback = function(color, alpha)
        Settings.Misc.FOVCircleColor = color
        Settings.Misc.FOVCircleAlpha = alpha
    end
})

local HitmarkerToggle = VisualsSection:Toggle({
    Name = "Hitmarker",
    Flag = "Hitmarker",
    Default = false,
    Callback = function(value)
        Settings.Misc.Hitmarker = value
    end
})

local HitmarkerSoundToggle = VisualsSection:Toggle({
    Name = "Hitmarker Sound",
    Flag = "HitmarkerSound",
    Default = false,
    Callback = function(value)
        Settings.Misc.HitmarkerSound = value
    end
})

--[[ MISC PAGE ]]--

local MiscSection = MiscPage:Section({Name = "Player Settings", Side = 1})

local BHopToggle = MiscSection:Toggle({
    Name = "Bunny Hop",
    Flag = "BHop",
    Default = false,
    Callback = function(value)
        Settings.Misc.BHop = value
    end
})

local NoClipToggle = MiscSection:Toggle({
    Name = "No Clip",
    Flag = "NoClip",
    Default = false,
    Callback = function(value)
        Settings.Misc.NoClip = value
    end
})

local WalkspeedSlider = MiscSection:Slider({
    Name = "Walkspeed",
    Flag = "Walkspeed",
    Min = 16,
    Max = 200,
    Decimals = 0,
    Suffix = "",
    Default = 16,
    Callback = function(value)
        Settings.Misc.Walkspeed = value
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            LocalPlayer.Character.Humanoid.WalkSpeed = value
        end
    end
})

local JumpPowerSlider = MiscSection:Slider({
    Name = "Jump Power",
    Flag = "JumpPower",
    Min = 50,
    Max = 200,
    Decimals = 0,
    Suffix = "",
    Default = 50,
    Callback = function(value)
        Settings.Misc.JumpPower = value
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            LocalPlayer.Character.Humanoid.JumpPower = value
        end
    end
})

-- Settings Page
Library:CreateSettingsPage(Window, Watermark, KeybindList)

--[[ ENHANCED ESP SYSTEM ]]--

local ESPObjects = {}
local VelocityHistory = {}
local Hitmarkers = {}

-- Create Drawing objects for each player with enhanced features
local function createESP(player)
    if player == LocalPlayer then return end
    
    ESPObjects[player] = {
        Box = Drawing.new("Square"),
        BoxOutline = Drawing.new("Square"),
        Name = Drawing.new("Text"),
        HealthBar = Drawing.new("Square"),
        HealthText = Drawing.new("Text"),
        Distance = Drawing.new("Text"),
        Tracer = Drawing.new("Line"),
        Snapline = Drawing.new("Line"),
        CornerBox = {}
    }
    
    -- Initialize corner boxes
    for i = 1, 4 do
        ESPObjects[player].CornerBox[i] = Drawing.new("Line")
        ESPObjects[player].CornerBox[i].Thickness = 2
        ESPObjects[player].CornerBox[i].Visible = false
    end
    
    -- Set properties
    for _, obj in pairs(ESPObjects[player]) do
        if type(obj) == "table" and obj.Visible ~= nil then
            obj.Visible = false
            if obj.Color then obj.Color = Settings.ESP.TextColor end
        end
    end
    
    ESPObjects[player].Box.Color = Settings.ESP.BoxColor
    ESPObjects[player].Box.Thickness = 2
    ESPObjects[player].Box.Filled = false
    
    ESPObjects[player].BoxOutline.Color = Color3.fromRGB(0, 0, 0)
    ESPObjects[player].BoxOutline.Thickness = 4
    ESPObjects[player].BoxOutline.Filled = false
    ESPObjects[player].BoxOutline.Visible = false
    
    ESPObjects[player].Tracer.Color = Settings.ESP.TracerColor
    ESPObjects[player].Tracer.Thickness = 1
    
    ESPObjects[player].Snapline.Color = Settings.ESP.TracerColor
    ESPObjects[player].Snapline.Thickness = 1
    
    ESPObjects[player].Name.Size = 16
    ESPObjects[player].Name.Center = true
    ESPObjects[player].Name.Outline = true
    ESPObjects[player].Name.Color = Settings.ESP.TextColor
    
    ESPObjects[player].HealthBar.Color = Settings.ESP.HealthColor
    ESPObjects[player].HealthBar.Filled = true
    ESPObjects[player].HealthBar.Thickness = 1
    
    ESPObjects[player].HealthText.Size = 12
    ESPObjects[player].HealthText.Center = true
    ESPObjects[player].HealthText.Outline = true
    ESPObjects[player].HealthText.Color = Color3.fromRGB(255, 255, 255)
    
    ESPObjects[player].Distance.Size = 12
    ESPObjects[player].Distance.Center = true
    ESPObjects[player].Distance.Outline = true
    ESPObjects[player].Distance.Color = Settings.ESP.TextColor
    
    -- Initialize velocity history for prediction
    VelocityHistory[player] = {}
end

-- Get character bounds for proper box sizing
local function getCharacterBounds(character)
    if not character then return nil end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil end
    
    local head = character:FindFirstChild("Head")
    local lowerTorso = character:FindFirstChild("LowerTorso") or rootPart
    
    if head and lowerTorso then
        local headPos = head.Position
        local lowerPos = lowerTorso.Position
        local height = (headPos.Y - lowerPos.Y) * 1.5 -- Add some padding
        local width = height * 0.6
        
        return {
            Position = rootPart.Position,
            Height = math.abs(height),
            Width = math.abs(width)
        }
    end
    
    return {
        Position = rootPart.Position,
        Height = 5,
        Width = 3
    }
end

-- Update ESP with proper box sizing
local function updateESP()
    if not Settings.ESP.Enabled then
        for _, objects in pairs(ESPObjects) do
            for _, obj in pairs(objects) do
                if type(obj) == "table" and obj.Visible ~= nil then
                    obj.Visible = false
                end
            end
        end
        return
    end
    
    for player, objects in pairs(ESPObjects) do
        if player and player.Character and player.Character:FindFirstChild("Humanoid") then
            local character = player.Character
            local humanoid = character:FindFirstChild("Humanoid")
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            
            if not rootPart or not humanoid then continue end
            
            -- Team check
            if Settings.ESP.TeamCheck and player.Team == LocalPlayer.Team and LocalPlayer.Team ~= nil then
                for _, obj in pairs(objects) do
                    if type(obj) == "table" and obj.Visible ~= nil then
                        obj.Visible = false
                    end
                end
                continue
            end
            
            -- Get proper bounds
            local bounds = getCharacterBounds(character)
            if not bounds then continue end
            
            -- Check if on screen
            local screenPos, onScreen = Camera:WorldToViewportPoint(bounds.Position)
            local distance = (Camera.CFrame.Position - bounds.Position).Magnitude
            
            if onScreen then
                -- Calculate box size based on actual character height
                local scale = 500 / distance
                local boxHeight = bounds.Height * scale
                local boxWidth = bounds.Width * scale
                
                -- Position calculations
                local boxX = screenPos.X - boxWidth/2
                local boxY = screenPos.Y - boxHeight/2
                
                -- Draw Box
                if Settings.ESP.Boxes then
                    if Settings.ESP.BoxCorner then
                        -- Corner box
                        local cornerSize = math.min(boxWidth, boxHeight) * 0.3
                        
                        -- Top left
                        objects.CornerBox[1].Visible = true
                        objects.CornerBox[1].Color = Settings.ESP.BoxColor
                        objects.CornerBox[1].From = Vector2.new(boxX, boxY)
                        objects.CornerBox[1].To = Vector2.new(boxX + cornerSize, boxY)
                        
                        -- Top right
                        objects.CornerBox[2].Visible = true
                        objects.CornerBox[2].Color = Settings.ESP.BoxColor
                        objects.CornerBox[2].From = Vector2.new(boxX + boxWidth, boxY)
                        objects.CornerBox[2].To = Vector2.new(boxX + boxWidth - cornerSize, boxY)
                        
                        -- Bottom left
                        objects.CornerBox[3].Visible = true
                        objects.CornerBox[3].Color = Settings.ESP.BoxColor
                        objects.CornerBox[3].From = Vector2.new(boxX, boxY + boxHeight)
                        objects.CornerBox[3].To = Vector2.new(boxX + cornerSize, boxY + boxHeight)
                        
                        -- Bottom right
                        objects.CornerBox[4].Visible = true
                        objects.CornerBox[4].Color = Settings.ESP.BoxColor
                        objects.CornerBox[4].From = Vector2.new(boxX + boxWidth, boxY + boxHeight)
                        objects.CornerBox[4].To = Vector2.new(boxX + boxWidth - cornerSize, boxY + boxHeight)
                        
                        objects.Box.Visible = false
                    else
                        -- Regular box
                        objects.Box.Visible = true
                        objects.Box.Color = Settings.ESP.BoxColor
                        objects.Box.Position = Vector2.new(boxX, boxY)
                        objects.Box.Size = Vector2.new(boxWidth, boxHeight)
                        
                        -- Box outline
                        if Settings.ESP.BoxOutline then
                            objects.BoxOutline.Visible = true
                            objects.BoxOutline.Position = Vector2.new(boxX - 1, boxY - 1)
                            objects.BoxOutline.Size = Vector2.new(boxWidth + 2, boxHeight + 2)
                        else
                            objects.BoxOutline.Visible = false
                        end
                    end
                else
                    objects.Box.Visible = false
                    objects.BoxOutline.Visible = false
                    for i = 1, 4 do
                        objects.CornerBox[i].Visible = false
                    end
                end
                
                -- Draw Name
                if Settings.ESP.Names then
                    objects.Name.Visible = true
                    objects.Name.Color = Settings.ESP.TextColor
                    objects.Name.Position = Vector2.new(screenPos.X, boxY - 20)
                    objects.Name.Text = player.Name
                else
                    objects.Name.Visible = false
                end
                
                -- Draw Health
                if Settings.ESP.Health and humanoid then
                    local healthPercent = humanoid.Health / humanoid.MaxHealth
                    local healthBarHeight = boxHeight * healthPercent
                    
                    objects.HealthBar.Visible = true
                    objects.HealthBar.Color = Settings.ESP.HealthColor
                    objects.HealthBar.Position = Vector2.new(boxX - 5, boxY + boxHeight - healthBarHeight)
                    objects.HealthBar.Size = Vector2.new(3, healthBarHeight)
                    
                    objects.HealthText.Visible = true
                    objects.HealthText.Color = Settings.ESP.TextColor
                    objects.HealthText.Position = Vector2.new(boxX - 15, boxY + boxHeight/2)
                    objects.HealthText.Text = math.floor(humanoid.Health)
                else
                    objects.HealthBar.Visible = false
                    objects.HealthText.Visible = false
                end
                
                -- Draw Distance
                if Settings.ESP.Distance then
                    objects.Distance.Visible = true
                    objects.Distance.Color = Settings.ESP.TextColor
                    objects.Distance.Position = Vector2.new(screenPos.X, boxY + boxHeight + 5)
                    objects.Distance.Text = math.floor(distance) .. " studs"
                else
                    objects.Distance.Visible = false
                end
                
                -- Draw Tracer (from bottom center)
                if Settings.ESP.Tracers then
                    objects.Tracer.Visible = true
                    objects.Tracer.Color = Settings.ESP.TracerColor
                    objects.Tracer.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
                    objects.Tracer.To = Vector2.new(screenPos.X, screenPos.Y)
                else
                    objects.Tracer.Visible = false
                end
                
                -- Draw Snapline (from player)
                if Settings.ESP.Snaplines then
                    objects.Snapline.Visible = true
                    objects.Snapline.Color = Settings.ESP.TracerColor
                    objects.Snapline.From = Vector2.new(screenPos.X, screenPos.Y)
                    objects.Snapline.To = Vector2.new(screenPos.X, screenPos.Y - 50)
                else
                    objects.Snapline.Visible = false
                end
            else
                -- Hide all if not on screen
                for _, obj in pairs(objects) do
                    if type(obj) == "table" and obj.Visible ~= nil then
                        obj.Visible = false
                    end
                end
            end
        else
            -- Hide if character invalid
            for _, obj in pairs(objects) do
                if type(obj) == "table" and obj.Visible ~= nil then
                    obj.Visible = false
                end
            end
        end
    end
end

--[[ ENHANCED AIMBOT SYSTEM ]]--

-- Track velocity for prediction
local function updateVelocityHistory()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                if not VelocityHistory[player] then
                    VelocityHistory[player] = {}
                end
                
                table.insert(VelocityHistory[player], {
                    Position = rootPart.Position,
                    Time = tick()
                })
                
                -- Keep last 10 positions
                if #VelocityHistory[player] > 10 then
                    table.remove(VelocityHistory[player], 1)
                end
            end
        end
    end
end

-- Advanced prediction
local function getPredictedPosition(player, targetPart)
    if not targetPart then return targetPart.Position end
    
    local currentPos = targetPart.Position
    local currentTime = tick()
    
    if not Settings.Aimbot.AutoPrediction then
        return currentPos + targetPart.Velocity * Settings.Aimbot.Prediction
    end
    
    -- Advanced prediction based on history
    local history = VelocityHistory[player]
    if not history or #history < 2 then
        return currentPos + targetPart.Velocity * Settings.Aimbot.Prediction
    end
    
    if Settings.Aimbot.PredictionType == "Linear" then
        return currentPos + targetPart.Velocity * Settings.Aimbot.Prediction
        
    elseif Settings.Aimbot.PredictionType == "Velocity" then
        local avgVelocity = Vector3.new()
        for i = 2, #history do
            local deltaPos = history[i].Position - history[i-1].Position
            local deltaTime = history[i].Time - history[i-1].Time
            if deltaTime > 0 then
                avgVelocity = avgVelocity + (deltaPos / deltaTime)
            end
        end
        avgVelocity = avgVelocity / (#history - 1)
        return currentPos + avgVelocity * Settings.Aimbot.Prediction
        
    elseif Settings.Aimbot.PredictionType == "Acceleration" then
        if #history >= 3 then
            local v1 = (history[2].Position - history[1].Position) / (history[2].Time - history[1].Time)
            local v2 = (history[3].Position - history[2].Position) / (history[3].Time - history[2].Time)
            local acceleration = (v2 - v1) / (history[3].Time - history[1].Time)
            return currentPos + targetPart.Velocity * Settings.Aimbot.Prediction + 0.5 * acceleration * (Settings.Aimbot.Prediction^2)
        end
    end
    
    return currentPos + targetPart.Velocity * Settings.Aimbot.Prediction
end

-- Get target part based on setting
local function getTargetPart(character)
    if Settings.Aimbot.TargetPart == "Nearest" then
        -- Find nearest visible part
        local parts = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"}
        local nearestPart = nil
        local nearestDistance = math.huge
        
        for _, partName in pairs(parts) do
            local part = character:FindFirstChild(partName)
            if part then
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local crosshairPos = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
                    local targetScreenPos = Vector2.new(screenPos.X, screenPos.Y)
                    local distance = (targetScreenPos - crosshairPos).Magnitude
                    
                    if distance < nearestDistance then
                        nearestDistance = distance
                        nearestPart = part
                    end
                end
            end
        end
        
        return nearestPart or character:FindFirstChild("HumanoidRootPart")
    else
        return character:FindFirstChild(Settings.Aimbot.TargetPart) or character:FindFirstChild("HumanoidRootPart")
    end
end

-- Get closest target with improved checks
local function getClosestTarget()
    local closestTarget = nil
    local closestDistance = Settings.Aimbot.FOV
    local closestPlayer = nil
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            -- Team check
            if Settings.Aimbot.TeamCheck and player.Team == LocalPlayer.Team and LocalPlayer.Team ~= nil then
                continue
            end
            
            local targetPart = getTargetPart(player.Character)
            if not targetPart then continue end
            
            -- Get predicted position
            local targetPosition = getPredictedPosition(player, targetPart)
            
            -- Check if on screen
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPosition)
            
            if onScreen then
                -- Calculate distance from crosshair
                local crosshairPos = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
                local targetScreenPos = Vector2.new(screenPos.X, screenPos.Y)
                local distance = (targetScreenPos - crosshairPos).Magnitude
                
                if distance < closestDistance then
                    -- Visible check
                    if Settings.Aimbot.VisibleCheck then
                        local ray = Ray.new(Camera.CFrame.Position, (targetPosition - Camera.CFrame.Position).Unit * 1000)
                        local ignoreList = {LocalPlayer.Character}
                        local hit, position = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
                        
                        -- Wallbang check
                        if Settings.Aimbot.Wallbang and hit then
                            local material = hit.Material
                            -- Check if material is wallbangable
                            -- This is simplified, you'd need a proper material list
                            if hit.Transparency > 0.5 then
                                closestDistance = distance
                                closestTarget = targetPart
                                closestPlayer = player
                            end
                        elseif hit and (hit:IsDescendantOf(player.Character) or hit:IsDescendantOf(player.Character)) then
                            closestDistance = distance
                            closestTarget = targetPart
                            closestPlayer = player
                        end
                    else
                        closestDistance = distance
                        closestTarget = targetPart
                        closestPlayer = player
                    end
                end
            end
        end
    end
    
    if closestPlayer then
        Settings.Aimbot.CurrentTarget = closestPlayer
    end
    
    return closestTarget
end

-- Lock-on system
local function updateLock()
    if not Settings.Aimbot.Enabled then return end
    
    local keyPressed = false
    
    -- Check key state based on input type
    if typeof(Settings.Aimbot.LockKey) == "EnumItem" then
        if Settings.Aimbot.LockKey.Name:find("MouseButton") then
            keyPressed = UserInputService:IsMouseButtonPressed(Settings.Aimbot.LockKey)
        else
            keyPressed = UserInputService:IsKeyDown(Settings.Aimbot.LockKey)
        end
    end
    
    -- Handle lock mode
    if Settings.Aimbot.LockMode == "Hold" then
        Settings.Aimbot.Locked = keyPressed
    elseif Settings.Aimbot.LockMode == "Toggle" then
        if keyPressed and not Settings.Aimbot.LastKeyState then
            Settings.Aimbot.Locked = not Settings.Aimbot.Locked
        end
        Settings.Aimbot.LastKeyState = keyPressed
    end
    
    -- Apply aimbot when locked
    if Settings.Aimbot.Locked then
        local target = getClosestTarget()
        if target then
            local targetPos = target.Position
            
            -- Add prediction
            if Settings.Aimbot.Prediction > 0 then
                targetPos = targetPos + target.Velocity * Settings.Aimbot.Prediction
            end
            
            if Settings.Aimbot.SilentAim then
                -- Silent aim would modify bullet direction
                -- This is more complex and would require hooking
            else
                -- Normal aimbot
                local currentLook = Camera.CFrame.LookVector
                local targetLook = (targetPos - Camera.CFrame.Position).Unit
                
                -- Smooth aim
                local smoothness = Settings.Aimbot.Smoothness
                local newLook = currentLook:Lerp(targetLook, smoothness)
                
                Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, Camera.CFrame.Position + newLook)
            end
            
            -- Auto shoot
            if Settings.Aimbot.AutoShoot then
                -- Simulate click
                mouse1press()
                task.wait(0.01)
                mouse1release()
            end
        end
    end
end

--[[ VISUAL ELEMENTS ]]--

-- Create FOV Circle
local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Thickness = 1
FOVCircle.NumSides = 60
FOVCircle.Radius = Settings.Aimbot.FOV
FOVCircle.Filled = false
FOVCircle.Color = Settings.Aimbot.FOVColor
FOVCircle.Transparency = Settings.Aimbot.FOVAlpha

-- Create Crosshair
local CrosshairLines = {}
for i = 1, 4 do
    CrosshairLines[i] = Drawing.new("Line")
    CrosshairLines[i].Visible = false
    CrosshairLines[i].Thickness = Settings.Misc.CrosshairThickness
    CrosshairLines[i].Color = Settings.Misc.CrosshairColor
    CrosshairLines[i].Transparency = 1
end

-- Create Visual FOV Circle
local VisualFOVCircle = Drawing.new("Circle")
VisualFOVCircle.Visible = false
VisualFOVCircle.Thickness = 1
VisualFOVCircle.NumSides = 60
VisualFOVCircle.Filled = false
VisualFOVCircle.Color = Settings.Misc.FOVCircleColor
VisualFOVCircle.Transparency = Settings.Misc.FOVCircleAlpha

-- Update visuals
local function updateVisuals()
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    local size = Settings.Misc.CrosshairSize
    local gap = Settings.Misc.CrosshairGap
    
    -- Update FOV Circle (aimbot)
    if Settings.Aimbot.ShowFOV then
        FOVCircle.Visible = true
        FOVCircle.Radius = Settings.Aimbot.FOV
        FOVCircle.Color = Settings.Aimbot.FOVColor
        FOVCircle.Transparency = Settings.Aimbot.FOVAlpha
        FOVCircle.Position = center
    else
        FOVCircle.Visible = false
    end
    
    -- Update Crosshair
    if Settings.Misc.Crosshair then
        for i = 1, 4 do
            CrosshairLines[i].Visible = true
            CrosshairLines[i].Thickness = Settings.Misc.CrosshairThickness
            CrosshairLines[i].Color = Settings.Misc.CrosshairColor
        end
        
        -- Left
        CrosshairLines[1].From = Vector2.new(center.X - size - gap, center.Y)
        CrosshairLines[1].To = Vector2.new(center.X - gap, center.Y)
        
        -- Right
        CrosshairLines[2].From = Vector2.new(center.X + gap, center.Y)
        CrosshairLines[2].To = Vector2.new(center.X + size + gap, center.Y)
        
        -- Top
        CrosshairLines[3].From = Vector2.new(center.X, center.Y - size - gap)
        CrosshairLines[3].To = Vector2.new(center.X, center.Y - gap)
        
        -- Bottom
        CrosshairLines[4].From = Vector2.new(center.X, center.Y + gap)
        CrosshairLines[4].To = Vector2.new(center.X, center.Y + size + gap)
    else
        for i = 1, 4 do
            CrosshairLines[i].Visible = false
        end
    end
    
    -- Update Visual FOV Circle
    if Settings.Misc.FOVCircle then
        VisualFOVCircle.Visible = true
        VisualFOVCircle.Radius = Settings.Misc.FOVRadius
        VisualFOVCircle.Color = Settings.Misc.FOVCircleColor
        VisualFOVCircle.Transparency = Settings.Misc.FOVCircleAlpha
        VisualFOVCircle.Position = center
    else
        VisualFOVCircle.Visible = false
    end
end

-- Bunny Hop
local function bhop()
    if not Settings.Misc.BHop then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end
    
    if humanoid.FloorMaterial ~= Enum.Material.Air then
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            humanoid.Jump = true
        end
    end
end

-- No Clip (simplified)
local function noclip()
    if not Settings.Misc.NoClip then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
end

--[[ MAIN LOOP ]]--

-- Update velocity history
RunService.Heartbeat:Connect(function()
    updateVelocityHistory()
end)

-- Main render loop
RunService.RenderStepped:Connect(function()
    -- Update ESP
    updateESP()
    
    -- Update lock-on
    updateLock()
    
    -- Update visuals
    updateVisuals()
    
    -- Misc features
    bhop()
    noclip()
end)

--[[ INITIALIZATION ]]--

-- Initialize ESP for existing players
for _, player in pairs(Players:GetPlayers()) do
    createESP(player)
end

-- Connect player added event
Players.PlayerAdded:Connect(function(player)
    createESP(player)
end)

-- Clean up when players leave
Players.PlayerRemoving:Connect(function(player)
    if ESPObjects[player] then
        for _, obj in pairs(ESPObjects[player]) do
            if type(obj) == "table" and obj.Remove then
                obj:Remove()
            end
        end
        ESPObjects[player] = nil
    end
    VelocityHistory[player] = nil
end)

-- Notification when script loads
Library:Notification("Success", "aqua loaded :0", 3)

print("aqua loaded!")
