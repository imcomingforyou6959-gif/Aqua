-- aqua
-- Run by onlyonestands

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/imcomingforyou6959-gif/Mitro/refs/heads/main/virtual"))()

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Stats = game:GetService("Stats")

-- Create main window
local Window = Library:Window({
    Name = "Universal Script",
    Size = UDim2.new(0, 751, 0, 539)
})

-- Watermark and Keybind List
local Watermark = Library:Watermark("Universal")
local KeybindList = Library:KeybindList()

-- Create pages
local AimbotPage = Window:Page({Name = "Aimbot", Columns = 2})
local ESPPage = Window:Page({Name = "ESP", Columns = 2})
local MiscPage = Window:Page({Name = "Misc", Columns = 2})
local SettingsPage = Library:CreateSettingsPage(Window, Watermark, KeybindList)

-- Settings table
local Settings = {
    Aimbot = {
        Enabled = false,
        Smoothness = 0.5,
        FOV = 90,
        TeamCheck = true,
        VisibleCheck = true,
        TargetPart = "Head",
        Prediction = 0.1,
        ShowFOV = true,
        FOVColor = Color3.fromRGB(255, 255, 255),
        FOVAlpha = 0.5,
        LockKey = "RightControl",
        LockMode = "Hold",
        Locked = false,
        LastKeyState = false
    },
    ESP = {
        Enabled = false,
        Boxes = true,
        Names = true,
        Health = true,
        Distance = true,
        TeamCheck = true,
        BoxColor = Color3.fromRGB(255, 0, 0),
        TextColor = Color3.fromRGB(255, 255, 255)
    },
    Misc = {
        Walkspeed = 16,
        WalkspeedEnabled = false,
        JumpPower = 50,
        JumpEnabled = false
    }
}

--[[ AIMBOT PAGE ]]--

local AimbotMain = AimbotPage:Section({Name = "Main Settings", Side = 1})

-- Enable Toggle
AimbotMain:Toggle({
    Name = "Enable Aimbot",
    Flag = "AimbotEnabled",
    Default = false,
    Callback = function(value)
        Settings.Aimbot.Enabled = value
    end
})

-- Keybind for aimbot
AimbotMain:Label("Aimbot Key"):Keybind({
    Name = "Aimbot Key",
    Flag = "AimbotKey",
    Default = Enum.KeyCode.RightControl,
    Mode = "Hold",
    Callback = function(key, mode)
        Settings.Aimbot.LockKey = key
        Settings.Aimbot.LockMode = mode
    end
})

-- Smoothness Slider
AimbotMain:Slider({
    Name = "Smoothness",
    Flag = "AimbotSmoothness",
    Min = 0.1,
    Max = 1,
    Decimals = 0.01,
    Suffix = "",
    Default = 0.5,
    Callback = function(value)
        Settings.Aimbot.Smoothness = value
    end
})

-- FOV Slider
AimbotMain:Slider({
    Name = "FOV Size",
    Flag = "AimbotFOV",
    Min = 10,
    Max = 360,
    Decimals = 0,
    Suffix = "Â°",
    Default = 90,
    Callback = function(value)
        Settings.Aimbot.FOV = value
    end
})

-- Prediction Slider
AimbotMain:Slider({
    Name = "Prediction",
    Flag = "AimbotPrediction",
    Min = 0,
    Max = 0.5,
    Decimals = 0.01,
    Suffix = "s",
    Default = 0.1,
    Callback = function(value)
        Settings.Aimbot.Prediction = value
    end
})

-- Target Settings (Side 2)
local AimbotTarget = AimbotPage:Section({Name = "Target Settings", Side = 2})

-- Team Check
AimbotTarget:Toggle({
    Name = "Team Check",
    Flag = "AimbotTeamCheck",
    Default = true,
    Callback = function(value)
        Settings.Aimbot.TeamCheck = value
    end
})

-- Visible Check
AimbotTarget:Toggle({
    Name = "Visible Check",
    Flag = "AimbotVisibleCheck",
    Default = true,
    Callback = function(value)
        Settings.Aimbot.VisibleCheck = value
    end
})

-- Show FOV Circle
AimbotTarget:Toggle({
    Name = "Show FOV Circle",
    Flag = "AimbotShowFOV",
    Default = true,
    Callback = function(value)
        Settings.Aimbot.ShowFOV = value
    end
})

-- Target Part Dropdown
AimbotTarget:Dropdown({
    Name = "Target Part",
    Flag = "AimbotTargetPart",
    Items = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", "Torso"},
    Default = "Head",
    Multi = false,
    Callback = function(value)
        Settings.Aimbot.TargetPart = value
    end
})

-- FOV Color Picker
AimbotTarget:Label("FOV Color"):Colorpicker({
    Flag = "AimbotFOVColor",
    Default = Color3.fromRGB(255, 255, 255),
    Alpha = 0.5,
    Callback = function(color, alpha)
        Settings.Aimbot.FOVColor = color
        Settings.Aimbot.FOVAlpha = alpha
    end
})

--[[ ESP PAGE ]]--

local ESPMain = ESPPage:Section({Name = "ESP Settings", Side = 1})

-- Enable ESP
ESPMain:Toggle({
    Name = "Enable ESP",
    Flag = "ESPEnabled",
    Default = false,
    Callback = function(value)
        Settings.ESP.Enabled = value
    end
})

-- Boxes Toggle
ESPMain:Toggle({
    Name = "Boxes",
    Flag = "ESPBoxes",
    Default = true,
    Callback = function(value)
        Settings.ESP.Boxes = value
    end
})

-- Names Toggle
ESPMain:Toggle({
    Name = "Names",
    Flag = "ESPNames",
    Default = true,
    Callback = function(value)
        Settings.ESP.Names = value
    end
})

-- Health Toggle
ESPMain:Toggle({
    Name = "Health",
    Flag = "ESPHealth",
    Default = true,
    Callback = function(value)
        Settings.ESP.Health = value
    end
})

-- Distance Toggle
ESPMain:Toggle({
    Name = "Distance",
    Flag = "ESPDistance",
    Default = true,
    Callback = function(value)
        Settings.ESP.Distance = value
    end
})

-- Team Check Toggle
ESPMain:Toggle({
    Name = "Team Check",
    Flag = "ESPTeamCheck",
    Default = true,
    Callback = function(value)
        Settings.ESP.TeamCheck = value
    end
})

-- ESP Colors Section (Side 2)
local ESPColors = ESPPage:Section({Name = "Colors", Side = 2})

-- Box Color
ESPColors:Label("Box Color"):Colorpicker({
    Flag = "ESPBoxColor",
    Default = Color3.fromRGB(255, 0, 0),
    Alpha = 1,
    Callback = function(color)
        Settings.ESP.BoxColor = color
    end
})

-- Text Color
ESPColors:Label("Text Color"):Colorpicker({
    Flag = "ESPTextColor",
    Default = Color3.fromRGB(255, 255, 255),
    Alpha = 1,
    Callback = function(color)
        Settings.ESP.TextColor = color
    end
})

--[[ MISC PAGE ]]--

local MiscSection = MiscPage:Section({Name = "Movement", Side = 1})

-- Walkspeed Toggle
MiscSection:Toggle({
    Name = "Walkspeed",
    Flag = "WalkspeedEnabled",
    Default = false,
    Callback = function(value)
        Settings.Misc.WalkspeedEnabled = value
    end
})

-- Walkspeed Slider
MiscSection:Slider({
    Name = "Walkspeed Value",
    Flag = "Walkspeed",
    Min = 16,
    Max = 200,
    Decimals = 0,
    Suffix = "",
    Default = 16,
    Callback = function(value)
        Settings.Misc.Walkspeed = value
        if Settings.Misc.WalkspeedEnabled and LocalPlayer.Character then
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = value
            end
        end
    end
})

-- Jump Power Toggle
MiscSection:Toggle({
    Name = "Jump Power",
    Flag = "JumpEnabled",
    Default = false,
    Callback = function(value)
        Settings.Misc.JumpEnabled = value
    end
})

-- Jump Power Slider
MiscSection:Slider({
    Name = "Jump Power Value",
    Flag = "JumpPower",
    Min = 50,
    Max = 200,
    Decimals = 0,
    Suffix = "",
    Default = 50,
    Callback = function(value)
        Settings.Misc.JumpPower = value
        if Settings.Misc.JumpEnabled and LocalPlayer.Character then
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.JumpPower = value
            end
        end
    end
})

--[[ ENHANCED AIMBOT IMPLEMENTATION ]]--

-- Aimbot Core Functions
local function getTargetPart(character)
    local part = character:FindFirstChild(Settings.Aimbot.TargetPart)
    if part then return part end
    -- Fallbacks
    part = character:FindFirstChild("Head") or character:FindFirstChild("Torso") or character:FindFirstChild("HumanoidRootPart")
    return part
end

local function isVisible(part)
    local origin = Camera.CFrame.Position
    local direction = part.Position - origin
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}

    local result = workspace:Raycast(origin, direction, rayParams)
    return not result or result.Instance:IsDescendantOf(part.Parent)
end

local function getClosestEnemyInFOV()
    if not Settings.Aimbot.Enabled then return nil end
    
    local closestPlayer = nil
    local closestDistance = Settings.Aimbot.FOV
    local screenCenter = Camera.ViewportSize / 2

    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if not player.Character then continue end

        -- Team check
        if Settings.Aimbot.TeamCheck then
            if player.TeamColor == LocalPlayer.TeamColor or (player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team) then
                continue
            end
        end

        local targetPart = getTargetPart(player.Character)
        if not targetPart then continue end

        -- Predicted position
        local targetPos = targetPart.Position
        if Settings.Aimbot.Prediction > 0 then
            local velocity = targetPart.Velocity
            if velocity.Magnitude > 1 and velocity.Magnitude < 1200 then
                local ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
                targetPos = targetPos + velocity * (ping + Settings.Aimbot.Prediction)
            end
        end

        -- On screen?
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
        if not onScreen then continue end

        -- Distance from crosshair
        local distance = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
        if distance > Settings.Aimbot.FOV then continue end

        -- Visibility
        if Settings.Aimbot.VisibleCheck and not isVisible(targetPart) then
            continue
        end

        if distance < closestDistance then
            closestDistance = distance
            closestPlayer = player
        end
    end

    return closestPlayer
end

local function smoothLookAt(targetPos)
    local currentLook = Camera.CFrame.LookVector
    local targetLook = (targetPos - Camera.CFrame.Position).Unit
    local smoothness = Settings.Aimbot.Smoothness
    local newLook = currentLook:Lerp(targetLook, smoothness)
    Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, Camera.CFrame.Position + newLook)
end

-- FOV Circle Drawing
local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Thickness = 2
FOVCircle.NumSides = 60
FOVCircle.Filled = false

local function updateFOVCircle()
    if Settings.Aimbot.ShowFOV and Settings.Aimbot.Enabled then
        FOVCircle.Visible = true
        FOVCircle.Radius = Settings.Aimbot.FOV
        FOVCircle.Color = Settings.Aimbot.FOVColor
        FOVCircle.Transparency = Settings.Aimbot.FOVAlpha
        FOVCircle.Position = Camera.ViewportSize / 2
    else
        FOVCircle.Visible = false
    end
end

-- Key state tracking
local keyPressed = false
local lastKeyState = false
local aimbotActive = false

local function updateAimbotState()
    if not Settings.Aimbot.Enabled then
        aimbotActive = false
        return
    end

    local key = Settings.Aimbot.LockKey
    keyPressed = false
    
    -- Determine if key is pressed
    if typeof(key) == "string" then
        for _, enum in pairs(Enum.KeyCode:GetEnumItems()) do
            if enum.Name == key then
                keyPressed = UserInputService:IsKeyDown(enum)
                break
            end
        end
        if not keyPressed then
            for _, enum in pairs(Enum.UserInputType:GetEnumItems()) do
                if enum.Name == key then
                    if enum == Enum.UserInputType.MouseButton1 then
                        keyPressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
                    elseif enum == Enum.UserInputType.MouseButton2 then
                        keyPressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
                    elseif enum == Enum.UserInputType.MouseButton3 then
                        keyPressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton3)
                    end
                    break
                end
            end
        end
    elseif typeof(key) == "EnumItem" then
        if key.Name:find("MouseButton") then
            keyPressed = UserInputService:IsMouseButtonPressed(key)
        else
            keyPressed = UserInputService:IsKeyDown(key)
        end
    end

    if Settings.Aimbot.LockMode == "Hold" then
        aimbotActive = keyPressed
    elseif Settings.Aimbot.LockMode == "Toggle" then
        if keyPressed and not lastKeyState then
            aimbotActive = not aimbotActive
        end
        lastKeyState = keyPressed
    end
end

-- Main render loop
RunService:BindToRenderStep("Aimbot", Enum.RenderPriority.Camera.Value + 1, function()
    updateFOVCircle()
    updateAimbotState()

    if not aimbotActive then return end

    local target = getClosestEnemyInFOV()
    if target and target.Character then
        local targetPart = getTargetPart(target.Character)
        if targetPart then
            local targetPos = targetPart.Position
            if Settings.Aimbot.Prediction > 0 then
                local velocity = targetPart.Velocity
                if velocity.Magnitude > 1 and velocity.Magnitude < 1200 then
                    local ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
                    targetPos = targetPos + velocity * (ping + Settings.Aimbot.Prediction)
                end
            end
            smoothLookAt(targetPos)
        end
    end
end)

--[[ ESP FUNCTIONS ]]--

local ESPObjects = {}

local function createESP(player)
    if player == LocalPlayer then return end
    
    ESPObjects[player] = {
        Box = Drawing.new("Square"),
        Name = Drawing.new("Text"),
        Health = Drawing.new("Text"),
        Distance = Drawing.new("Text")
    }
    
    -- Box
    ESPObjects[player].Box.Thickness = 2
    ESPObjects[player].Box.Filled = false
    ESPObjects[player].Box.Visible = false
    
    -- Name
    ESPObjects[player].Name.Size = 16
    ESPObjects[player].Name.Center = true
    ESPObjects[player].Name.Outline = true
    ESPObjects[player].Name.Visible = false
    
    -- Health
    ESPObjects[player].Health.Size = 14
    ESPObjects[player].Health.Center = true
    ESPObjects[player].Health.Outline = true
    ESPObjects[player].Health.Visible = false
    
    -- Distance
    ESPObjects[player].Distance.Size = 12
    ESPObjects[player].Distance.Center = true
    ESPObjects[player].Distance.Outline = true
    ESPObjects[player].Distance.Visible = false
end

local function updateESP()
    if not Settings.ESP.Enabled then
        for _, objects in pairs(ESPObjects) do
            for _, obj in pairs(objects) do
                obj.Visible = false
            end
        end
        return
    end
    
    for player, objects in pairs(ESPObjects) do
        if not player or not player.Character then
            for _, obj in pairs(objects) do
                obj.Visible = false
            end
            continue
        end
        
        local character = player.Character
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        
        if not humanoid or not rootPart or humanoid.Health <= 0 then
            for _, obj in pairs(objects) do
                obj.Visible = false
            end
            continue
        end
        
        -- Team check
        if Settings.ESP.TeamCheck then
            if player.TeamColor == LocalPlayer.TeamColor or (player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team) then
                for _, obj in pairs(objects) do
                    obj.Visible = false
                end
                continue
            end
        end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
        local distance = (Camera.CFrame.Position - rootPart.Position).Magnitude
        
        if not onScreen then
            for _, obj in pairs(objects) do
                obj.Visible = false
            end
            continue
        end
        
        local scale = 500 / distance
        local boxHeight = 50 * scale
        local boxWidth = 30 * scale
        boxHeight = math.clamp(boxHeight, 20, 150)
        boxWidth = math.clamp(boxWidth, 15, 100)
        
        local boxX = screenPos.X - boxWidth/2
        local boxY = screenPos.Y - boxHeight/2
        
        -- Update colors
        objects.Box.Color = Settings.ESP.BoxColor
        objects.Name.Color = Settings.ESP.TextColor
        objects.Health.Color = Color3.new(1 - humanoid.Health/humanoid.MaxHealth, humanoid.Health/humanoid.MaxHealth, 0)
        objects.Distance.Color = Settings.ESP.TextColor
        
        -- Box
        if Settings.ESP.Boxes then
            objects.Box.Visible = true
            objects.Box.Position = Vector2.new(boxX, boxY)
            objects.Box.Size = Vector2.new(boxWidth, boxHeight)
        else
            objects.Box.Visible = false
        end
        
        -- Name
        if Settings.ESP.Names then
            objects.Name.Visible = true
            objects.Name.Position = Vector2.new(screenPos.X, boxY - 20)
            objects.Name.Text = player.Name
        else
            objects.Name.Visible = false
        end
        
        -- Health
        if Settings.ESP.Health then
            objects.Health.Visible = true
            objects.Health.Position = Vector2.new(screenPos.X + boxWidth/2 + 5, boxY)
            objects.Health.Text = math.floor(humanoid.Health) .. "/" .. math.floor(humanoid.MaxHealth)
        else
            objects.Health.Visible = false
        end
        
        -- Distance
        if Settings.ESP.Distance then
            objects.Distance.Visible = true
            objects.Distance.Position = Vector2.new(screenPos.X, boxY + boxHeight + 5)
            objects.Distance.Text = math.floor(distance) .. " studs"
        else
            objects.Distance.Visible = false
        end
    end
end

-- Initialize ESP
for _, player in pairs(Players:GetPlayers()) do
    createESP(player)
end

Players.PlayerAdded:Connect(createESP)
Players.PlayerRemoving:Connect(function(player)
    if ESPObjects[player] then
        for _, obj in pairs(ESPObjects[player]) do
            obj:Remove()
        end
        ESPObjects[player] = nil
    end
end)

-- Character added - apply movement
LocalPlayer.CharacterAdded:Connect(function(character)
    local humanoid = character:WaitForChild("Humanoid", 5)
    if Settings.Misc.WalkspeedEnabled then
        humanoid.WalkSpeed = Settings.Misc.Walkspeed
    end
    if Settings.Misc.JumpEnabled then
        humanoid.JumpPower = Settings.Misc.JumpPower
    end
end)

-- Movement heartbeat
RunService.Heartbeat:Connect(function()
    if LocalPlayer.Character then
        local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            if Settings.Misc.WalkspeedEnabled then
                humanoid.WalkSpeed = Settings.Misc.Walkspeed
            end
            if Settings.Misc.JumpEnabled then
                humanoid.JumpPower = Settings.Misc.JumpPower
            end
        end
    end
end)

-- ESP update loop
RunService.RenderStepped:Connect(updateESP)

-- Cleanup
Library.Unload = function()
    FOVCircle:Remove()
    for _, objects in pairs(ESPObjects) do
        for _, obj in pairs(objects) do
            obj:Remove()
        end
    end
    -- Call original unload if exists
    if rawget(Library, "OriginalUnload") then
        Library:OriginalUnload()
    end
end

Library:Notification("Success", "Universal Script Loaded!", 3)
print("Universal Script loaded successfully!")
