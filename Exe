-- Run by onlyonestands

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/imcomingforyou6959-gif/Mitro/refs/heads/main/virtual"))()

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Settings table
local Settings = {
    Aimbot = {
        Enabled = false,
        Smoothness = 0.5,
        FOV = 90,
        TeamCheck = true,
        VisibleCheck = true,
        TargetPart = "Head",
        Prediction = 0.1,
        PredictionType = "Linear",
        ShowFOV = true,
        FOVColor = Color3.fromRGB(255, 255, 255),
        FOVAlpha = 0.5,
        LockKey = Enum.UserInputType.MouseButton2,
        LockMode = "Hold",
        Locked = false,
        CurrentTarget = nil,
        SilentAim = false,
        Wallbang = false,
        AutoShoot = false,
        AutoPrediction = true,
        LastKeyState = false
    },
    ESP = {
        Enabled = false,
        Boxes = true,
        Names = true,
        Health = true,
        Distance = true,
        TeamCheck = true,
        Tracers = false,
        Chams = false,
        Snaplines = false,
        BoxColor = Color3.fromRGB(255, 0, 0),
        TracerColor = Color3.fromRGB(255, 255, 255),
        TextColor = Color3.fromRGB(255, 255, 255),
        HealthColor = Color3.fromRGB(0, 255, 0),
        BoxOutline = true,
        BoxCorner = false
    },
    Misc = {
        Crosshair = false,
        CrosshairColor = Color3.fromRGB(255, 255, 255),
        CrosshairSize = 10,
        CrosshairGap = 0,
        CrosshairThickness = 2,
        FOVCircle = false,
        FOVCircleColor = Color3.fromRGB(255, 255, 255),
        FOVCircleAlpha = 0.5,
        FOVRadius = 100,
        BHop = false,
        NoClip = false,
        Walkspeed = 16,
        JumpPower = 50,
        WalkspeedEnabled = false,
        JumpEnabled = false
    }
}

-- Create the main window
local Window = Library:Window({
    Name = "Universal Script | aqua",
    Size = UDim2.new(0, 751, 0, 539)
})

-- Watermark
local Watermark = Library:Watermark("aqua v2")

-- Keybind list
local KeybindList = Library:KeybindList()

-- Create pages
local AimbotPage = Window:Page({Name = "Aimbot", Columns = 2})
local ESPPage = Window:Page({Name = "ESP", Columns = 2})
local VisualsPage = Window:Page({Name = "Visuals", Columns = 2})
local MiscPage = Window:Page({Name = "Misc", Columns = 2})
local SettingsPage = Library:CreateSettingsPage(Window, Watermark, KeybindList)

--[[ AIMBOT PAGE ]]--

-- Aimbot Main Section (Side 1)
local AimbotMain = AimbotPage:Section({Name = "Main Settings", Side = 1})

local AimbotToggle = AimbotMain:Toggle({
    Name = "Enable Aimbot",
    Flag = "AimbotEnabled",
    Default = false,
    Callback = function(value)
        Settings.Aimbot.Enabled = value
    end
})

local AimbotSmoothness = AimbotMain:Slider({
    Name = "Smoothness",
    Flag = "AimbotSmoothness",
    Min = 0.1,
    Max = 1,
    Decimals = 0.01,
    Suffix = "",
    Default = 0.5,
    Callback = function(value)
        Settings.Aimbot.Smoothness = value
    end
})

local AimbotFOV = AimbotMain:Slider({
    Name = "FOV Size",
    Flag = "AimbotFOV",
    Min = 10,
    Max = 360,
    Decimals = 0,
    Suffix = "Â°",
    Default = 90,
    Callback = function(value)
        Settings.Aimbot.FOV = value
    end
})

-- Aimbot Prediction Section
local PredictionSection = AimbotPage:Section({Name = "Prediction", Side = 1})

local AimbotPrediction = PredictionSection:Slider({
    Name = "Prediction Amount",
    Flag = "AimbotPrediction",
    Min = 0,
    Max = 1,
    Decimals = 0.01,
    Suffix = "s",
    Default = 0.1,
    Callback = function(value)
        Settings.Aimbot.Prediction = value
    end
})

-- Aimbot Target Section (Side 2)
local AimbotTarget = AimbotPage:Section({Name = "Target Settings", Side = 2})

local TeamCheckToggle = AimbotTarget:Toggle({
    Name = "Team Check",
    Flag = "AimbotTeamCheck",
    Default = true,
    Callback = function(value)
        Settings.Aimbot.TeamCheck = value
    end
})

local VisibleCheckToggle = AimbotTarget:Toggle({
    Name = "Visible Check",
    Flag = "AimbotVisibleCheck",
    Default = true,
    Callback = function(value)
        Settings.Aimbot.VisibleCheck = value
    end
})

local ShowFOVToggle = AimbotTarget:Toggle({
    Name = "Show FOV Circle",
    Flag = "AimbotShowFOV",
    Default = true,
    Callback = function(value)
        Settings.Aimbot.ShowFOV = value
    end
})

local TargetPartDropdown = AimbotTarget:Dropdown({
    Name = "Target Part",
    Flag = "AimbotTargetPart",
    Items = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"},
    Default = "Head",
    Multi = false,
    Callback = function(value)
        Settings.Aimbot.TargetPart = value
    end
})

-- Keybind Section (Side 2)
local KeybindSection = AimbotPage:Section({Name = "Keybinds", Side = 2})

local AimbotKeybind = KeybindSection:Label("Aimbot Key"):Keybind({
    Name = "AimbotKey",
    Flag = "AimbotKey",
    Default = Enum.UserInputType.MouseButton2,
    Mode = "Hold",
    Callback = function(value)
        Settings.Aimbot.LockKey = value
    end
})

local FOVColorPicker = KeybindSection:Label("FOV Color"):Colorpicker({
    Flag = "AimbotFOVColor",
    Default = Color3.fromRGB(255, 255, 255),
    Alpha = 0.5,
    Callback = function(color, alpha)
        Settings.Aimbot.FOVColor = color
        Settings.Aimbot.FOVAlpha = alpha
    end
})

--[[ ESP PAGE ]]--

-- ESP Main Section (Side 1)
local ESPMain = ESPPage:Section({Name = "ESP Settings", Side = 1})

local ESPToggle = ESPMain:Toggle({
    Name = "Enable ESP",
    Flag = "ESPEnabled",
    Default = false,
    Callback = function(value)
        Settings.ESP.Enabled = value
    end
})

local ESPBoxesToggle = ESPMain:Toggle({
    Name = "Boxes",
    Flag = "ESPBoxes",
    Default = true,
    Callback = function(value)
        Settings.ESP.Boxes = value
    end
})

local ESPNamesToggle = ESPMain:Toggle({
    Name = "Names",
    Flag = "ESPNames",
    Default = true,
    Callback = function(value)
        Settings.ESP.Names = value
    end
})

local ESPHealthToggle = ESPMain:Toggle({
    Name = "Health",
    Flag = "ESPHealth",
    Default = true,
    Callback = function(value)
        Settings.ESP.Health = value
    end
})

local ESPDistanceToggle = ESPMain:Toggle({
    Name = "Distance",
    Flag = "ESPDistance",
    Default = true,
    Callback = function(value)
        Settings.ESP.Distance = value
    end
})

local ESPTracersToggle = ESPMain:Toggle({
    Name = "Tracers",
    Flag = "ESPTracers",
    Default = false,
    Callback = function(value)
        Settings.ESP.Tracers = value
    end
})

local ESPTeamCheckToggle = ESPMain:Toggle({
    Name = "Team Check",
    Flag = "ESPTeamCheck",
    Default = true,
    Callback = function(value)
        Settings.ESP.TeamCheck = value
    end
})

-- ESP Colors Section (Side 2)
local ESPColorSection = ESPPage:Section({Name = "Colors", Side = 2})

local ESPBoxColor = ESPColorSection:Label("Box Color"):Colorpicker({
    Flag = "ESPBoxColor",
    Default = Color3.fromRGB(255, 0, 0),
    Alpha = 1,
    Callback = function(color)
        Settings.ESP.BoxColor = color
    end
})

local ESPTextColor = ESPColorSection:Label("Text Color"):Colorpicker({
    Flag = "ESPTextColor",
    Default = Color3.fromRGB(255, 255, 255),
    Alpha = 1,
    Callback = function(color)
        Settings.ESP.TextColor = color
    end
})

--[[ VISUALS PAGE ]]--

local VisualsSection = VisualsPage:Section({Name = "Visuals", Side = 1})

local CrosshairToggle = VisualsSection:Toggle({
    Name = "Crosshair",
    Flag = "Crosshair",
    Default = false,
    Callback = function(value)
        Settings.Misc.Crosshair = value
    end
})

local CrosshairColor = VisualsSection:Label("Crosshair Color"):Colorpicker({
    Flag = "CrosshairColor",
    Default = Color3.fromRGB(255, 255, 255),
    Alpha = 1,
    Callback = function(color)
        Settings.Misc.CrosshairColor = color
    end
})

local CrosshairSize = VisualsSection:Slider({
    Name = "Crosshair Size",
    Flag = "CrosshairSize",
    Min = 5,
    Max = 30,
    Decimals = 0,
    Suffix = "px",
    Default = 10,
    Callback = function(value)
        Settings.Misc.CrosshairSize = value
    end
})

local FOVCircleToggle = VisualsSection:Toggle({
    Name = "FOV Circle",
    Flag = "FOVCircle",
    Default = false,
    Callback = function(value)
        Settings.Misc.FOVCircle = value
    end
})

local FOVCircleRadius = VisualsSection:Slider({
    Name = "FOV Radius",
    Flag = "FOVRadius",
    Min = 50,
    Max = 500,
    Decimals = 0,
    Suffix = "px",
    Default = 100,
    Callback = function(value)
        Settings.Misc.FOVRadius = value
    end
})

local FOVCircleColor = VisualsSection:Label("FOV Circle Color"):Colorpicker({
    Flag = "FOVCircleColor",
    Default = Color3.fromRGB(255, 255, 255),
    Alpha = 0.5,
    Callback = function(color, alpha)
        Settings.Misc.FOVCircleColor = color
        Settings.Misc.FOVCircleAlpha = alpha
    end
})

--[[ MISC PAGE ]]--

local MiscSection = MiscPage:Section({Name = "Player Settings", Side = 1})

local BHopToggle = MiscSection:Toggle({
    Name = "Bunny Hop",
    Flag = "BHop",
    Default = false,
    Callback = function(value)
        Settings.Misc.BHop = value
    end
})

local WalkspeedToggle = MiscSection:Toggle({
    Name = "Walkspeed",
    Flag = "WalkspeedEnabled",
    Default = false,
    Callback = function(value)
        Settings.Misc.WalkspeedEnabled = value
    end
})

local WalkspeedSlider = MiscSection:Slider({
    Name = "Walkspeed Value",
    Flag = "Walkspeed",
    Min = 16,
    Max = 200,
    Decimals = 0,
    Suffix = "",
    Default = 16,
    Callback = function(value)
        Settings.Misc.Walkspeed = value
    end
})

local JumpToggle = MiscSection:Toggle({
    Name = "Jump Power",
    Flag = "JumpEnabled",
    Default = false,
    Callback = function(value)
        Settings.Misc.JumpEnabled = value
    end
})

local JumpPowerSlider = MiscSection:Slider({
    Name = "Jump Power Value",
    Flag = "JumpPower",
    Min = 50,
    Max = 200,
    Decimals = 0,
    Suffix = "",
    Default = 50,
    Callback = function(value)
        Settings.Misc.JumpPower = value
    end
})

--[[ UTILITY FUNCTIONS ]]--

-- Get ping for prediction
local function getPing()
    local stats = game:GetService("Stats")
    local ping = stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
    return ping
end

-- Predict position based on velocity
local function predictPosition(part, predictionAmount)
    if not part then return nil end
    local velocity = part.Velocity
    local speed = velocity.Magnitude
    
    -- Don't predict if not moving fast enough or too fast
    if speed < 1 or speed > 1200 then
        return part.Position
    end
    
    local ping = getPing()
    return part.Position + velocity * (ping + predictionAmount)
end

-- Get target part from character
local function getTargetPart(character)
    if not character then return nil end
    return character:FindFirstChild(Settings.Aimbot.TargetPart) or 
           character:FindFirstChild("HumanoidRootPart")
end

-- Get closest target to crosshair
local function getClosestTarget()
    if not Settings.Aimbot.Enabled then return nil end
    
    local closestTarget = nil
    local closestDistance = Settings.Aimbot.FOV
    local crosshairPos = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if not player.Character then continue end
        
        -- Team check
        if Settings.Aimbot.TeamCheck and player.Team == LocalPlayer.Team and LocalPlayer.Team ~= nil then
            continue
        end
        
        local targetPart = getTargetPart(player.Character)
        if not targetPart then continue end
        
        -- Get predicted position
        local targetPos = predictPosition(targetPart, Settings.Aimbot.Prediction)
        if not targetPos then continue end
        
        -- Check if on screen
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
        if not onScreen then continue end
        
        -- Calculate distance from crosshair
        local targetScreenPos = Vector2.new(screenPos.X, screenPos.Y)
        local distance = (targetScreenPos - crosshairPos).Magnitude
        
        if distance < closestDistance then
            -- Visible check
            if Settings.Aimbot.VisibleCheck then
                local ray = Ray.new(Camera.CFrame.Position, (targetPos - Camera.CFrame.Position).Unit * 1000)
                local ignoreList = {LocalPlayer.Character}
                local hit, position = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
                
                if hit and (hit:IsDescendantOf(player.Character) or hit == targetPart) then
                    closestDistance = distance
                    closestTarget = targetPart
                    Settings.Aimbot.CurrentTarget = player
                end
            else
                closestDistance = distance
                closestTarget = targetPart
                Settings.Aimbot.CurrentTarget = player
            end
        end
    end
    
    return closestTarget
end

-- Update lock state based on key
local function updateLockState()
    if not Settings.Aimbot.Enabled then 
        Settings.Aimbot.Locked = false
        return 
    end
    
    local keyPressed = false
    
    -- Check key state based on input type
    if typeof(Settings.Aimbot.LockKey) == "EnumItem" then
        if Settings.Aimbot.LockKey.Name:find("MouseButton") then
            -- Mouse button
            if Settings.Aimbot.LockKey == Enum.UserInputType.MouseButton1 then
                keyPressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
            elseif Settings.Aimbot.LockKey == Enum.UserInputType.MouseButton2 then
                keyPressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
            elseif Settings.Aimbot.LockKey == Enum.UserInputType.MouseButton3 then
                keyPressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton3)
            end
        else
            -- Keyboard key
            keyPressed = UserInputService:IsKeyDown(Settings.Aimbot.LockKey)
        end
    end
    
    -- Handle lock mode
    if Settings.Aimbot.LockMode == "Hold" then
        Settings.Aimbot.Locked = keyPressed
    elseif Settings.Aimbot.LockMode == "Toggle" then
        if keyPressed and not Settings.Aimbot.LastKeyState then
            Settings.Aimbot.Locked = not Settings.Aimbot.Locked
        end
        Settings.Aimbot.LastKeyState = keyPressed
    end
end

-- Apply aimbot
local function applyAimbot()
    if not Settings.Aimbot.Enabled or not Settings.Aimbot.Locked then return end
    
    local target = getClosestTarget()
    if not target then return end
    
    -- Get predicted position
    local targetPos = predictPosition(target, Settings.Aimbot.Prediction)
    if not targetPos then return end
    
    -- Calculate look direction
    local currentLook = Camera.CFrame.LookVector
    local targetLook = (targetPos - Camera.CFrame.Position).Unit
    
    -- Smooth aim
    local smoothness = Settings.Aimbot.Smoothness
    local newLook = currentLook:Lerp(targetLook, smoothness)
    
    -- Apply camera rotation
    Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, Camera.CFrame.Position + newLook)
end

--[[ ENHANCED ESP SYSTEM ]]--

local ESPObjects = {}
local VelocityHistory = {}

-- Create Drawing objects for each player
local function createESP(player)
    if player == LocalPlayer then return end
    
    ESPObjects[player] = {
        Box = Drawing.new("Square"),
        BoxOutline = Drawing.new("Square"),
        Name = Drawing.new("Text"),
        HealthBar = Drawing.new("Square"),
        HealthText = Drawing.new("Text"),
        Distance = Drawing.new("Text"),
        Tracer = Drawing.new("Line"),
        Snapline = Drawing.new("Line")
    }
    
    -- Set properties
    ESPObjects[player].Box.Color = Settings.ESP.BoxColor
    ESPObjects[player].Box.Thickness = 2
    ESPObjects[player].Box.Filled = false
    ESPObjects[player].Box.Visible = false
    
    ESPObjects[player].BoxOutline.Color = Color3.fromRGB(0, 0, 0)
    ESPObjects[player].BoxOutline.Thickness = 4
    ESPObjects[player].BoxOutline.Filled = false
    ESPObjects[player].BoxOutline.Visible = false
    
    ESPObjects[player].Name.Size = 16
    ESPObjects[player].Name.Center = true
    ESPObjects[player].Name.Outline = true
    ESPObjects[player].Name.Color = Settings.ESP.TextColor
    ESPObjects[player].Name.Visible = false
    
    ESPObjects[player].HealthBar.Color = Settings.ESP.HealthColor
    ESPObjects[player].HealthBar.Filled = true
    ESPObjects[player].HealthBar.Thickness = 1
    ESPObjects[player].HealthBar.Visible = false
    
    ESPObjects[player].HealthText.Size = 12
    ESPObjects[player].HealthText.Center = true
    ESPObjects[player].HealthText.Outline = true
    ESPObjects[player].HealthText.Color = Color3.fromRGB(255, 255, 255)
    ESPObjects[player].HealthText.Visible = false
    
    ESPObjects[player].Distance.Size = 12
    ESPObjects[player].Distance.Center = true
    ESPObjects[player].Distance.Outline = true
    ESPObjects[player].Distance.Color = Settings.ESP.TextColor
    ESPObjects[player].Distance.Visible = false
    
    ESPObjects[player].Tracer.Color = Settings.ESP.TracerColor
    ESPObjects[player].Tracer.Thickness = 1
    ESPObjects[player].Tracer.Visible = false
    
    ESPObjects[player].Snapline.Color = Settings.ESP.TracerColor
    ESPObjects[player].Snapline.Thickness = 1
    ESPObjects[player].Snapline.Visible = false
end

-- Get character bounds for proper box sizing
local function getCharacterBounds(character)
    if not character then return nil end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local head = character:FindFirstChild("Head")
    
    if not rootPart or not humanoid then return nil end
    
    -- Calculate height based on head and root part
    local height = 5 -- Default
    if head then
        height = (head.Position.Y - rootPart.Position.Y) * 2.2 -- Add padding
    else
        height = humanoid.Height * 1.5
    end
    
    -- Calculate width based on height
    local width = height * 0.6
    
    return {
        Position = rootPart.Position,
        Height = math.max(height, 3),
        Width = math.max(width, 2)
    }
end

-- Update ESP
local function updateESP()
    if not Settings.ESP.Enabled then
        for _, objects in pairs(ESPObjects) do
            for _, obj in pairs(objects) do
                if obj and obj.Visible ~= nil then
                    obj.Visible = false
                end
            end
        end
        return
    end
    
    for player, objects in pairs(ESPObjects) do
        if not player or not player.Character then
            -- Hide if player invalid
            for _, obj in pairs(objects) do
                if obj and obj.Visible ~= nil then
                    obj.Visible = false
                end
            end
            continue
        end
        
        local character = player.Character
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        
        if not humanoid or not rootPart or humanoid.Health <= 0 then
            for _, obj in pairs(objects) do
                if obj and obj.Visible ~= nil then
                    obj.Visible = false
                end
            end
            continue
        end
        
        -- Team check
        if Settings.ESP.TeamCheck and player.Team == LocalPlayer.Team and LocalPlayer.Team ~= nil then
            for _, obj in pairs(objects) do
                if obj and obj.Visible ~= nil then
                    obj.Visible = false
                end
            end
            continue
        end
        
        -- Get bounds
        local bounds = getCharacterBounds(character)
        if not bounds then
            for _, obj in pairs(objects) do
                if obj and obj.Visible ~= nil then
                    obj.Visible = false
                end
            end
            continue
        end
        
        -- Check if on screen
        local screenPos, onScreen = Camera:WorldToViewportPoint(bounds.Position)
        local distance = (Camera.CFrame.Position - bounds.Position).Magnitude
        
        if not onScreen then
            for _, obj in pairs(objects) do
                if obj and obj.Visible ~= nil then
                    obj.Visible = false
                end
            end
            continue
        end
        
        -- Calculate box size based on distance
        local scale = 500 / math.max(distance, 1)
        local boxHeight = bounds.Height * scale
        local boxWidth = bounds.Width * scale
        
        -- Clamp sizes to reasonable values
        boxHeight = math.clamp(boxHeight, 20, 200)
        boxWidth = math.clamp(boxWidth, 15, 150)
        
        -- Box position
        local boxX = screenPos.X - boxWidth/2
        local boxY = screenPos.Y - boxHeight/2
        
        -- Draw Box
        if Settings.ESP.Boxes then
            objects.Box.Visible = true
            objects.Box.Color = Settings.ESP.BoxColor
            objects.Box.Position = Vector2.new(boxX, boxY)
            objects.Box.Size = Vector2.new(boxWidth, boxHeight)
            
            -- Box outline
            if Settings.ESP.BoxOutline then
                objects.BoxOutline.Visible = true
                objects.BoxOutline.Position = Vector2.new(boxX - 1, boxY - 1)
                objects.BoxOutline.Size = Vector2.new(boxWidth + 2, boxHeight + 2)
            else
                objects.BoxOutline.Visible = false
            end
        else
            objects.Box.Visible = false
            objects.BoxOutline.Visible = false
        end
        
        -- Draw Name
        if Settings.ESP.Names then
            objects.Name.Visible = true
            objects.Name.Color = Settings.ESP.TextColor
            objects.Name.Position = Vector2.new(screenPos.X, boxY - 20)
            objects.Name.Text = player.Name
        else
            objects.Name.Visible = false
        end
        
        -- Draw Health
        if Settings.ESP.Health then
            local healthPercent = humanoid.Health / humanoid.MaxHealth
            local healthBarHeight = boxHeight * healthPercent
            
            objects.HealthBar.Visible = true
            objects.HealthBar.Color = Color3.new(1 - healthPercent, healthPercent, 0)
            objects.HealthBar.Position = Vector2.new(boxX - 5, boxY + boxHeight - healthBarHeight)
            objects.HealthBar.Size = Vector2.new(3, math.max(healthBarHeight, 1))
            
            objects.HealthText.Visible = true
            objects.HealthText.Color = Settings.ESP.TextColor
            objects.HealthText.Position = Vector2.new(boxX - 15, boxY + boxHeight/2)
            objects.HealthText.Text = math.floor(humanoid.Health)
        else
            objects.HealthBar.Visible = false
            objects.HealthText.Visible = false
        end
        
        -- Draw Distance
        if Settings.ESP.Distance then
            objects.Distance.Visible = true
            objects.Distance.Color = Settings.ESP.TextColor
            objects.Distance.Position = Vector2.new(screenPos.X, boxY + boxHeight + 5)
            objects.Distance.Text = math.floor(distance) .. " studs"
        else
            objects.Distance.Visible = false
        end
        
        -- Draw Tracer (from bottom center)
        if Settings.ESP.Tracers then
            objects.Tracer.Visible = true
            objects.Tracer.Color = Settings.ESP.TracerColor
            objects.Tracer.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
            objects.Tracer.To = Vector2.new(screenPos.X, screenPos.Y)
        else
            objects.Tracer.Visible = false
        end
    end
end

--[[ VISUAL ELEMENTS ]]--

-- Create FOV Circle (for aimbot)
local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Thickness = 1
FOVCircle.NumSides = 60
FOVCircle.Radius = Settings.Aimbot.FOV
FOVCircle.Filled = false
FOVCircle.Color = Settings.Aimbot.FOVColor
FOVCircle.Transparency = Settings.Aimbot.FOVAlpha

-- Create Crosshair
local CrosshairLines = {}
for i = 1, 4 do
    CrosshairLines[i] = Drawing.new("Line")
    CrosshairLines[i].Visible = false
    CrosshairLines[i].Thickness = Settings.Misc.CrosshairThickness
    CrosshairLines[i].Color = Settings.Misc.CrosshairColor
    CrosshairLines[i].Transparency = 1
end

-- Create Visual FOV Circle
local VisualFOVCircle = Drawing.new("Circle")
VisualFOVCircle.Visible = false
VisualFOVCircle.Thickness = 1
VisualFOVCircle.NumSides = 60
VisualFOVCircle.Filled = false
VisualFOVCircle.Color = Settings.Misc.FOVCircleColor
VisualFOVCircle.Transparency = Settings.Misc.FOVCircleAlpha

-- Update visuals
local function updateVisuals()
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    local size = Settings.Misc.CrosshairSize
    local gap = Settings.Misc.CrosshairGap
    
    -- Update FOV Circle (aimbot)
    if Settings.Aimbot.ShowFOV and Settings.Aimbot.Enabled then
        FOVCircle.Visible = true
        FOVCircle.Radius = Settings.Aimbot.FOV
        FOVCircle.Color = Settings.Aimbot.FOVColor
        FOVCircle.Transparency = Settings.Aimbot.FOVAlpha
        FOVCircle.Position = center
    else
        FOVCircle.Visible = false
    end
    
    -- Update Crosshair
    if Settings.Misc.Crosshair then
        for i = 1, 4 do
            CrosshairLines[i].Visible = true
            CrosshairLines[i].Thickness = Settings.Misc.CrosshairThickness
            CrosshairLines[i].Color = Settings.Misc.CrosshairColor
        end
        
        -- Left
        CrosshairLines[1].From = Vector2.new(center.X - size - gap, center.Y)
        CrosshairLines[1].To = Vector2.new(center.X - gap, center.Y)
        
        -- Right
        CrosshairLines[2].From = Vector2.new(center.X + gap, center.Y)
        CrosshairLines[2].To = Vector2.new(center.X + size + gap, center.Y)
        
        -- Top
        CrosshairLines[3].From = Vector2.new(center.X, center.Y - size - gap)
        CrosshairLines[3].To = Vector2.new(center.X, center.Y - gap)
        
        -- Bottom
        CrosshairLines[4].From = Vector2.new(center.X, center.Y + gap)
        CrosshairLines[4].To = Vector2.new(center.X, center.Y + size + gap)
    else
        for i = 1, 4 do
            CrosshairLines[i].Visible = false
        end
    end
    
    -- Update Visual FOV Circle
    if Settings.Misc.FOVCircle then
        VisualFOVCircle.Visible = true
        VisualFOVCircle.Radius = Settings.Misc.FOVRadius
        VisualFOVCircle.Color = Settings.Misc.FOVCircleColor
        VisualFOVCircle.Transparency = Settings.Misc.FOVCircleAlpha
        VisualFOVCircle.Position = center
    else
        VisualFOVCircle.Visible = false
    end
end

--[[ MISC FEATURES ]]--

-- Bunny Hop
local function bhop()
    if not Settings.Misc.BHop then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end
    
    if humanoid.FloorMaterial ~= Enum.Material.Air then
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            humanoid.Jump = true
        end
    end
end

-- Apply walkspeed and jump power
local function applyMovement()
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end
    
    if Settings.Misc.WalkspeedEnabled then
        humanoid.WalkSpeed = Settings.Misc.Walkspeed
    else
        humanoid.WalkSpeed = 16 -- Default
    end
    
    if Settings.Misc.JumpEnabled then
        humanoid.JumpPower = Settings.Misc.JumpPower
    else
        humanoid.JumpPower = 50 -- Default
    end
end

--[[ MAIN LOOP ]]--

-- Initialize ESP for existing players
for _, player in pairs(Players:GetPlayers()) do
    createESP(player)
end

-- Connect player added event
Players.PlayerAdded:Connect(function(player)
    createESP(player)
end)

-- Clean up when players leave
Players.PlayerRemoving:Connect(function(player)
    if ESPObjects[player] then
        for _, obj in pairs(ESPObjects[player]) do
            if obj and obj.Remove then
                pcall(function() obj:Remove() end)
            end
        end
        ESPObjects[player] = nil
    end
    VelocityHistory[player] = nil
end)

-- Main render loop
RunService.RenderStepped:Connect(function()
    -- Update lock state
    updateLockState()
    
    -- Apply aimbot
    applyAimbot()
    
    -- Update ESP
    updateESP()
    
    -- Update visuals
    updateVisuals()
    
    -- Misc features
    bhop()
    applyMovement()
end)

-- Heartbeat for physics-based updates
RunService.Heartbeat:Connect(function()
    -- Update velocity history for prediction
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                if not VelocityHistory[player] then
                    VelocityHistory[player] = {}
                end
                
                table.insert(VelocityHistory[player], {
                    Position = rootPart.Position,
                    Time = tick()
                })
                
                -- Keep last 5 positions
                if #VelocityHistory[player] > 5 then
                    table.remove(VelocityHistory[player], 1)
                end
            end
        end
    end
end)

-- Character added event to reset movement settings
LocalPlayer.CharacterAdded:Connect(function(character)
    -- Wait for humanoid to load
    local humanoid = character:WaitForChild("Humanoid", 5)
    
    -- Apply saved settings
    if Settings.Misc.WalkspeedEnabled then
        humanoid.WalkSpeed = Settings.Misc.Walkspeed
    end
    
    if Settings.Misc.JumpEnabled then
        humanoid.JumpPower = Settings.Misc.JumpPower
    end
end)

-- Notification when script loads
Library:Notification("Success", "aqua v2 loaded! Press Right Click to aim", 3)

print("aqua v2 loaded successfully!")
