local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/imcomingforyou6959-gif/STX-Firmware/refs/heads/main/Framwork"))()

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local VirtualUser = game:GetService("VirtualUser")
local Stats = game:GetService("Stats")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")

-- Helper: hex to Color3
local function hexToColor3(hex)
    hex = hex:gsub("#", "")
    local r = tonumber("0x" .. hex:sub(1,2)) / 255
    local g = tonumber("0x" .. hex:sub(3,4)) / 255
    local b = tonumber("0x" .. hex:sub(5,6)) / 255
    return Color3.new(r, g, b)
end

-- Helper: get ping for prediction
local function getPing()
    return Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
end

-- Settings table
local Settings = {
    Combat = {
        Aimbot = {
            Enabled = false,
            KeyName = "RightButton",
            KeyCode = Enum.UserInputType.MouseButton2,
            Smoothness = 0.3,
            FOV = 150,
            ShowFOV = false,
            FOVColor = Color3.fromRGB(255, 0, 0),
            TeamCheck = false,
            VisibleCheck = true,
            TargetPart = "Head",
            Prediction = 0.1,
            AutoPrediction = true,
            SmartLock = false,
            SmartLockIgnoreFOV = true,
        },
        Defense = {
            Enabled = false,
            Active = false,
            Attacker = nil,
        },
        Triggerbot = {
            Enabled = false,
            Delay = 0,
        },
        Friends = {
            Enabled = false,
            List = {},
            ListString = "",
        },
    },
    Visuals = {
        ESP = {
            Enabled = false,
            Box = true,
            Name = true,
            Health = true,
            Distance = true,
            Tracer = false,
            Skeleton = false,
            BoxColor = "#FF0000",
            NameColor = "#FFFFFF",
            HealthColor = "#00FF00",
            DistanceColor = "#FFFFFF",
            TracerColor = "#FFFFFF",
            SkeletonColor = "#FFFFFF",
        },
    },
    Misc = {
        Movement = {
            Walkspeed = { Enabled = false, Value = 16 },
            JumpPower = { Enabled = false, Value = 50 },
            CFrameSpeed = { Enabled = false, Value = 10 },
        },
        FPSBoost = {
            Enabled = false,
        },
        AntiAFK = false,
    },
    Settings = {
        MenuKey = Enum.KeyCode.RightAlt,
        MenuKeyName = "RightAlt",
    },
}

-- Initialize UI with custom key
local ui = library:Init(Settings.Settings.MenuKey)

-- Watermark
local watermark = library:Watermark("Aqua.lol")

-- Notifications
local notif = library:InitNotifications()

-- Create tabs
local CombatTab = ui:NewTab("Combat")
local VisualsTab = ui:NewTab("Visuals")
local MiscTab = ui:NewTab("Misc")
local SettingsTab = ui:NewTab("Settings")


CombatTab:NewLabel("Aimbot Settings")
local aimbotToggle = CombatTab:NewToggle("Enable Aimbot", false, function(state)
    Settings.Combat.Aimbot.Enabled = state
end)

-- Textbox keybind
CombatTab:NewLabel("Aimbot Key (e.g., RightButton, LeftControl, E)")
local keyInput = CombatTab:NewTextbox("Key", Settings.Combat.Aimbot.KeyName, "Key name", "all", "small", true, false, function(text)
    Settings.Combat.Aimbot.KeyName = text
    local success, result = pcall(function()
        if text:find("Button") then
            return Enum.UserInputType[text]
        else
            return Enum.KeyCode[text]
        end
    end)
    if success and result then
        Settings.Combat.Aimbot.KeyCode = result
    else
        notif:Notify("Invalid key name! Use RightButton, LeftControl, etc.", 3, "error", function() end)
    end
end)

-- FOV slider
CombatTab:NewSlider("FOV Size", "", false, nil, { min = 50, max = 500, default = 150 }, function(value)
    Settings.Combat.Aimbot.FOV = value
end)

-- Smoothness slider
CombatTab:NewSlider("Smoothness", "", false, nil, { min = 0.1, max = 0.8, default = 0.3 }, function(value)
    Settings.Combat.Aimbot.Smoothness = value
end)

-- Prediction slider
CombatTab:NewSlider("Prediction Amount (s)", "", false, nil, { min = 0, max = 0.5, default = 0.1, decimals = 2 }, function(value)
    Settings.Combat.Aimbot.Prediction = value
end)

CombatTab:NewToggle("Auto Prediction (scales with speed + ping)", true, function(state)
    Settings.Combat.Aimbot.AutoPrediction = state
end)

CombatTab:NewLabel("Smart Lock")
CombatTab:NewToggle("Enable Smart Lock", false, function(state)
    Settings.Combat.Aimbot.SmartLock = state
end)
CombatTab:NewToggle("Smart Lock Ignore FOV", true, function(state)
    Settings.Combat.Aimbot.SmartLockIgnoreFOV = state
end)

CombatTab:NewToggle("Show FOV Circle", true, function(state)
    Settings.Combat.Aimbot.ShowFOV = state
end)

CombatTab:NewLabel("FOV Color (hex, e.g., #FF0000)")
CombatTab:NewTextbox("FOV Color", "#FF0000", "#RRGGBB", "all", "small", true, false, function(hex)
    local success, color = pcall(hexToColor3, hex)
    if success then
        Settings.Combat.Aimbot.FOVColor = color
    else
        notif:Notify("Invalid hex color!", 2, "error", function() end)
    end
end)

-- Team check
CombatTab:NewToggle("Team Check", true, function(state)
    Settings.Combat.Aimbot.TeamCheck = state
end)

CombatTab:NewToggle("Visible Check", true, function(state)
    Settings.Combat.Aimbot.VisibleCheck = state
end)

-- Target part selector
CombatTab:NewLabel("Target Part")
local partSelector = CombatTab:NewSelector("Part", "Head", {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"}, function(selected)
    Settings.Combat.Aimbot.TargetPart = selected
end)

CombatTab:NewLabel("Friend Whitelist")
CombatTab:NewToggle("Enable Friend Whitelist", false, function(state)
    Settings.Combat.Friends.Enabled = state
end)
CombatTab:NewTextbox("Friends (comma-separated)", "", "User1,User2", "all", "small", true, false, function(text)
    Settings.Combat.Friends.ListString = text
    Settings.Combat.Friends.List = {}
    for name in text:gmatch("[^,%s]+") do
        table.insert(Settings.Combat.Friends.List, name)
    end
end)

-- Defense section
CombatTab:NewLabel("Defense")
local defenseToggle = CombatTab:NewToggle("Auto-lock on attacker", false, function(state)
    Settings.Combat.Defense.Enabled = state
    if not state then
        Settings.Combat.Defense.Active = false
        Settings.Combat.Defense.Attacker = nil
    end
end)

-- Triggerbot section
CombatTab:NewLabel("Triggerbot")
local triggerToggle = CombatTab:NewToggle("Enable Triggerbot", false, function(state)
    Settings.Combat.Triggerbot.Enabled = state
end)

CombatTab:NewSlider("Trigger Delay (ms)", "", false, nil, { min = 0, max = 500, default = 0 }, function(value)
    Settings.Combat.Triggerbot.Delay = value
end)


VisualsTab:NewLabel("ESP Settings")
local espToggle = VisualsTab:NewToggle("Enable ESP", false, function(state)
    Settings.Visuals.ESP.Enabled = state
end)

VisualsTab:NewToggle("Boxes", true, function(state)
    Settings.Visuals.ESP.Box = state
end)

VisualsTab:NewLabel("Box Color (hex)")
VisualsTab:NewTextbox("Box Color", "#FF0000", "#RRGGBB", "all", "small", true, false, function(hex)
    Settings.Visuals.ESP.BoxColor = hex
end)

VisualsTab:NewToggle("Names", true, function(state)
    Settings.Visuals.ESP.Name = state
end)

VisualsTab:NewLabel("Name Color (hex)")
VisualsTab:NewTextbox("Name Color", "#FFFFFF", "#RRGGBB", "all", "small", true, false, function(hex)
    Settings.Visuals.ESP.NameColor = hex
end)

VisualsTab:NewToggle("Health", true, function(state)
    Settings.Visuals.ESP.Health = state
end)

VisualsTab:NewLabel("Health Color (hex)")
VisualsTab:NewTextbox("Health Color", "#00FF00", "#RRGGBB", "all", "small", true, false, function(hex)
    Settings.Visuals.ESP.HealthColor = hex
end)

VisualsTab:NewToggle("Distance", true, function(state)
    Settings.Visuals.ESP.Distance = state
end)

VisualsTab:NewLabel("Distance Color (hex)")
VisualsTab:NewTextbox("Distance Color", "#FFFFFF", "#RRGGBB", "all", "small", true, false, function(hex)
    Settings.Visuals.ESP.DistanceColor = hex
end)

VisualsTab:NewToggle("Tracers", false, function(state)
    Settings.Visuals.ESP.Tracer = state
end)

VisualsTab:NewLabel("Tracer Color (hex)")
VisualsTab:NewTextbox("Tracer Color", "#FFFFFF", "#RRGGBB", "all", "small", true, false, function(hex)
    Settings.Visuals.ESP.TracerColor = hex
end)

VisualsTab:NewToggle("Skeleton ESP", false, function(state)
    Settings.Visuals.ESP.Skeleton = state
end)

VisualsTab:NewLabel("Skeleton Color (hex)")
VisualsTab:NewTextbox("Skeleton Color", "#FFFFFF", "#RRGGBB", "all", "small", true, false, function(hex)
    Settings.Visuals.ESP.SkeletonColor = hex
end)


MiscTab:NewLabel("Movement")
local wsToggle = MiscTab:NewToggle("Walkspeed", false, function(state)
    Settings.Misc.Movement.Walkspeed.Enabled = state
end)

MiscTab:NewSlider("Walkspeed Value", "", false, nil, { min = 16, max = 200, default = 16 }, function(value)
    Settings.Misc.Movement.Walkspeed.Value = value
    if Settings.Misc.Movement.Walkspeed.Enabled and LocalPlayer.Character then
        local hum = LocalPlayer.Character:FindFirstChild("Humanoid")
        if hum then hum.WalkSpeed = value end
    end
end)

local jpToggle = MiscTab:NewToggle("Jump Power", false, function(state)
    Settings.Misc.Movement.JumpPower.Enabled = state
end)

MiscTab:NewSlider("Jump Power Value", "", false, nil, { min = 50, max = 200, default = 50 }, function(value)
    Settings.Misc.Movement.JumpPower.Value = value
    if Settings.Misc.Movement.JumpPower.Enabled and LocalPlayer.Character then
        local hum = LocalPlayer.Character:FindFirstChild("Humanoid")
        if hum then hum.JumpPower = value end
    end
end)

-- CFrame Speed
local cframeToggle = MiscTab:NewToggle("CFrame Speed", false, function(state)
    Settings.Misc.Movement.CFrameSpeed.Enabled = state
end)

MiscTab:NewSlider("CFrame Speed Value", "", false, nil, { min = 1, max = 100, default = 10 }, function(value)
    Settings.Misc.Movement.CFrameSpeed.Value = value
end)

-- FPS Boost
MiscTab:NewToggle("FPS Boost (Low Materials)", false, function(state)
    Settings.Misc.FPSBoost.Enabled = state
    if state then
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("BasePart") and v.Material ~= Enum.Material.Plastic then
                v.Material = Enum.Material.Plastic
            end
        end
    end
end)

-- Anti-AFK
MiscTab:NewToggle("Anti-AFK", false, function(state)
    Settings.Misc.AntiAFK = state
end)

-- Panic button
MiscTab:NewLabel("Panic")
MiscTab:NewButton("⚠ PANIC (Teleport to ground)", function()
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        local root = char.HumanoidRootPart
        local pos = root.Position
        local rayParams = RaycastParams.new()
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        rayParams.FilterDescendantsInstances = {char}
        local result = workspace:Raycast(pos, Vector3.new(0, -500, 0), rayParams)
        if result then
            root.CFrame = CFrame.new(result.Position + Vector3.new(0, 5, 0))
            notif:Notify("Teleported to ground!", 3, "success", function() end)
        else
            notif:Notify("No ground found below!", 3, "error", function() end)
        end
    end
end)


SettingsTab:NewLabel("UI Settings")

-- UI Toggle Key (textbox)
SettingsTab:NewLabel("UI Toggle Key (e.g., RightAlt, LeftControl)")
local uiKeyInput = SettingsTab:NewTextbox("UI Key", Settings.Settings.MenuKeyName, "Key name", "all", "small", true, false, function(text)
    local success, result = pcall(function()
        return Enum.KeyCode[text]
    end)
    if success and result then
        Settings.Settings.MenuKey = result
        Settings.Settings.MenuKeyName = text
        notif:Notify("UI toggle key changed to " .. text .. ". Restart script to apply fully.", 5, "information", function() end)
    else
        notif:Notify("Invalid key name!", 2, "error", function() end)
    end
end)

-- Unload button
SettingsTab:NewLabel("Script Control")
SettingsTab:NewButton("Unload Script", function()
    ui:Remove()
    FOVCircle:Remove()
    cleanAllESP()
    notif = nil
    library = nil
end)

-- Rejoin button
SettingsTab:NewButton("Rejoin Server", function()
    TeleportService:Teleport(game.PlaceId, LocalPlayer)
end)

-- Server Hop button
SettingsTab:NewButton("Server Hop", function()
    local servers = HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?limit=100"))
    for _, server in ipairs(servers.data) do
        if server.playing < server.maxPlayers then
            TeleportService:TeleportToPlaceInstance(game.PlaceId, server.id, LocalPlayer)
            break
        end
    end
end)


local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Thickness = 2
FOVCircle.NumSides = 60
FOVCircle.Filled = false

local function IsEnemy(player)
    if player == LocalPlayer then return false end
    -- Friend whitelist
    if Settings.Combat.Friends.Enabled then
        for _, name in ipairs(Settings.Combat.Friends.List) do
            if player.Name:lower() == name:lower() or player.DisplayName:lower() == name:lower() then
                return false
            end
        end
    end
    if Settings.Combat.Aimbot.TeamCheck then
        if player.TeamColor == LocalPlayer.TeamColor or (player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team) then
            return false
        end
    end
    return true
end

local function IsVisible(targetPart)
    local origin = Camera.CFrame.Position
    local direction = targetPart.Position - origin
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
    local result = workspace:Raycast(origin, direction, rayParams)
    return not result or result.Instance:IsDescendantOf(targetPart.Parent)
end

local function GetTargetPart(character)
    if not character then return nil end
    local part = character:FindFirstChild(Settings.Combat.Aimbot.TargetPart)
    if not part then
        part = character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart")
    end
    return part
end

local function GetPredictedPosition(part)
    if not part then return part.Position end
    local pred = Settings.Combat.Aimbot.Prediction
    if Settings.Combat.Aimbot.AutoPrediction then
        local speed = part.Velocity.Magnitude
        if speed > 5 and speed < 200 then
            pred = pred * (speed / 50) + getPing()
        else
            pred = pred + getPing()
        end
    end
    return part.Position + part.Velocity * pred
end

local function GetNearestEnemy(ignoreFOV)
    local nearest = nil
    local nearestDist = math.huge
    local myPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myPos then return nil end
    myPos = myPos.Position

    for _, player in pairs(Players:GetPlayers()) do
        if not IsEnemy(player) then continue end
        if not player.Character then continue end
        local targetPart = GetTargetPart(player.Character)
        if not targetPart then continue end
        if Settings.Combat.Aimbot.VisibleCheck and not IsVisible(targetPart) then
            continue
        end
        local dist = (myPos - targetPart.Position).Magnitude
        if dist < nearestDist then
            nearestDist = dist
            nearest = targetPart
        end
    end
    return nearest
end

local function GetClosestTarget()
    local closest = nil
    local closestDist = Settings.Combat.Aimbot.FOV
    local screenCenter = Camera.ViewportSize / 2

    for _, player in pairs(Players:GetPlayers()) do
        if not IsEnemy(player) then continue end
        if not player.Character then continue end
        local targetPart = GetTargetPart(player.Character)
        if not targetPart then continue end

        if Settings.Combat.Aimbot.VisibleCheck and not IsVisible(targetPart) then
            continue
        end

        local targetPos = GetPredictedPosition(targetPart)
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
        if not onScreen or screenPos.Z <= 0 then continue end

        local dist = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
        if dist > Settings.Combat.Aimbot.FOV then continue end

        if dist < closestDist then
            closestDist = dist
            closest = targetPart
        end
    end
    return closest
end

local aimbotKeyPressed = false
local function updateKeyState()
    local key = Settings.Combat.Aimbot.KeyCode
    if not key then return end
    if typeof(key) == "EnumItem" then
        if key.Name:find("Button") then
            aimbotKeyPressed = UserInputService:IsMouseButtonPressed(key)
        else
            aimbotKeyPressed = UserInputService:IsKeyDown(key)
        end
    else
        aimbotKeyPressed = false
    end
end

local lastHealth = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") and LocalPlayer.Character.Humanoid.Health or 100
local function setupDamageDetection(char)
    local hum = char:WaitForChild("Humanoid")
    lastHealth = hum.Health
    hum:GetPropertyChangedSignal("Health"):Connect(function()
        if not Settings.Combat.Defense.Enabled then return end
        if hum.Health < lastHealth then
            local attacker = hum:FindFirstChild("creator") and hum.creator.Value
            if attacker and attacker.Parent then
                Settings.Combat.Defense.Active = true
                Settings.Combat.Defense.Attacker = attacker
                notif:Notify("Defense: Locking onto " .. attacker.Name, 2, "alert", function() end)
            end
        end
        lastHealth = hum.Health
    end)
end
LocalPlayer.CharacterAdded:Connect(setupDamageDetection)
if LocalPlayer.Character then
    setupDamageDetection(LocalPlayer.Character)
end

local function updateCFrameSpeed()
    if not Settings.Misc.Movement.CFrameSpeed.Enabled then return end
    if not LocalPlayer.Character then return end
    local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    if UserInputService:IsKeyDown(Enum.KeyCode.W) then
        hrp.CFrame = hrp.CFrame + Camera.CFrame.LookVector * Settings.Misc.Movement.CFrameSpeed.Value
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then
        hrp.CFrame = hrp.CFrame - Camera.CFrame.LookVector * Settings.Misc.Movement.CFrameSpeed.Value
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then
        hrp.CFrame = hrp.CFrame - Camera.CFrame.RightVector * Settings.Misc.Movement.CFrameSpeed.Value
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then
        hrp.CFrame = hrp.CFrame + Camera.CFrame.RightVector * Settings.Misc.Movement.CFrameSpeed.Value
    end
end

local lastTriggerTime = 0
local function doTrigger()
    if not Settings.Combat.Triggerbot.Enabled then return end
    local targetPart = GetClosestTarget()
    if targetPart then
        local targetPos = GetPredictedPosition(targetPart)
        local screenPos = Camera:WorldToViewportPoint(targetPos)
        local screenCenter = Camera.ViewportSize / 2
        local dist = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
        if dist < 10 then
            local now = tick()
            if now - lastTriggerTime > Settings.Combat.Triggerbot.Delay / 1000 then
                lastTriggerTime = now
                mouse1press()
                task.wait(0.02)
                mouse1release()
            end
        end
    end
end

local function updateMovement()
    if LocalPlayer.Character then
        local hum = LocalPlayer.Character:FindFirstChild("Humanoid")
        if hum then
            if Settings.Misc.Movement.Walkspeed.Enabled then
                hum.WalkSpeed = Settings.Misc.Movement.Walkspeed.Value
            end
            if Settings.Misc.Movement.JumpPower.Enabled then
                hum.JumpPower = Settings.Misc.Movement.JumpPower.Value
            end
        end
    end
end

LocalPlayer.Idled:Connect(function()
    if Settings.Misc.AntiAFK then
        VirtualUser:CaptureController()
        VirtualUser:ClickButton2(Vector2.new())
    end
end)

task.spawn(function()
    while true do
        task.wait(5)
        if Settings.Misc.FPSBoost.Enabled then
            for _, v in pairs(workspace:GetDescendants()) do
                if v:IsA("BasePart") and v.Material ~= Enum.Material.Plastic then
                    v.Material = Enum.Material.Plastic
                end
            end
        end
    end
end)

-- Main loop
RunService.RenderStepped:Connect(function()
    
    if Settings.Combat.Aimbot.ShowFOV and Settings.Combat.Aimbot.Enabled then
        FOVCircle.Visible = true
        FOVCircle.Radius = Settings.Combat.Aimbot.FOV
        FOVCircle.Color = Settings.Combat.Aimbot.FOVColor
        FOVCircle.Position = Camera.ViewportSize / 2
    else
        FOVCircle.Visible = false
    end

    updateKeyState()

    local targetPart = nil

    if Settings.Combat.Defense.Active and Settings.Combat.Defense.Attacker and Settings.Combat.Defense.Attacker.Parent then
        local attacker = Settings.Combat.Defense.Attacker
        if attacker.Character then
            targetPart = GetTargetPart(attacker.Character)
            if not attacker.Character or attacker.Character.Humanoid.Health <= 0 then
                Settings.Combat.Defense.Active = false
                Settings.Combat.Defense.Attacker = nil
            end
        else
            Settings.Combat.Defense.Active = false
            Settings.Combat.Defense.Attacker = nil
        end
    elseif Settings.Combat.Aimbot.SmartLock then
        targetPart = GetNearestEnemy(Settings.Combat.Aimbot.SmartLockIgnoreFOV)
    elseif Settings.Combat.Aimbot.Enabled and aimbotKeyPressed then
        targetPart = GetClosestTarget()
    end

    if targetPart then
        local targetPos = GetPredictedPosition(targetPart)
        local camPos = Camera.CFrame.Position
        local targetCF = CFrame.lookAt(camPos, targetPos)
        Camera.CFrame = Camera.CFrame:Lerp(targetCF, Settings.Combat.Aimbot.Smoothness)
    end

    doTrigger()
    updateMovement()
    updateCFrameSpeed()
end)

-- ============ ESP SYSTEM (FULLY NIL-PROTECTED) ============
local ESPCache = {}

-- Cleanup: remove all Drawing objects for a player
local function cleanESP(player)
    if ESPCache[player] then
        for _, obj in pairs(ESPCache[player]) do
            if type(obj) == "table" then
                -- Skeleton is a table of lines
                for _, line in ipairs(obj) do
                    if line and line.Remove then
                        pcall(line.Remove, line)
                    end
                end
            else
                -- Regular Drawing objects
                if obj and obj.Remove then
                    pcall(obj.Remove, obj)
                end
            end
        end
        ESPCache[player] = nil
    end
end

function cleanAllESP()
    for player, _ in pairs(ESPCache) do
        cleanESP(player)
    end
end

-- Get character joints for skeleton (with nil safety)
local function getJoints(character)
    if not character then return {} end
    local joints = {}
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return joints end

    if humanoid.RigType == Enum.HumanoidRigType.R15 then
        joints = {
            Head = character:FindFirstChild("Head"),
            UpperTorso = character:FindFirstChild("UpperTorso"),
            LowerTorso = character:FindFirstChild("LowerTorso"),
            LeftUpperArm = character:FindFirstChild("LeftUpperArm"),
            LeftLowerArm = character:FindFirstChild("LeftLowerArm"),
            LeftHand = character:FindFirstChild("LeftHand"),
            RightUpperArm = character:FindFirstChild("RightUpperArm"),
            RightLowerArm = character:FindFirstChild("RightLowerArm"),
            RightHand = character:FindFirstChild("RightHand"),
            LeftUpperLeg = character:FindFirstChild("LeftUpperLeg"),
            LeftLowerLeg = character:FindFirstChild("LeftLowerLeg"),
            RightUpperLeg = character:FindFirstChild("RightUpperLeg"),
            RightLowerLeg = character:FindFirstChild("RightLowerLeg"),
        }
    else -- R6
        joints = {
            Head = character:FindFirstChild("Head"),
            Torso = character:FindFirstChild("Torso"),
            LeftArm = character:FindFirstChild("Left Arm"),
            RightArm = character:FindFirstChild("Right Arm"),
            LeftLeg = character:FindFirstChild("Left Leg"),
            RightLeg = character:FindFirstChild("Right Leg"),
        }
    end
    return joints
end

-- Skeleton connections
local skeletonConnections = {
    R15 = {
        {"Head", "UpperTorso"},
        {"UpperTorso", "LowerTorso"},
        {"UpperTorso", "LeftUpperArm"},
        {"LeftUpperArm", "LeftLowerArm"},
        {"LeftLowerArm", "LeftHand"},
        {"UpperTorso", "RightUpperArm"},
        {"RightUpperArm", "RightLowerArm"},
        {"RightLowerArm", "RightHand"},
        {"LowerTorso", "LeftUpperLeg"},
        {"LeftUpperLeg", "LeftLowerLeg"},
        {"LowerTorso", "RightUpperLeg"},
        {"RightUpperLeg", "RightLowerLeg"},
    },
    R6 = {
        {"Head", "Torso"},
        {"Torso", "LeftArm"},
        {"Torso", "RightArm"},
        {"Torso", "LeftLeg"},
        {"Torso", "RightLeg"},
    }
}

-- Create ESP objects for a player (safe initialization)
local function createESP(player)
    if player == LocalPlayer then return end

    -- Create each Drawing object with pcall to catch failures
    local box = Drawing.new("Square")
    local nameObj = Drawing.new("Text")
    local healthObj = Drawing.new("Text")
    local distanceObj = Drawing.new("Text")
    local tracer = Drawing.new("Line")
    local skeleton = {}

    for i = 1, 12 do
        local line = Drawing.new("Line")
        if line then
            line.Visible = false
            line.Thickness = 2
            skeleton[i] = line
        end
    end

    -- Store them; if any creation failed, they may be nil – we'll handle in update
    ESPCache[player] = {
        Box = box,
        Name = nameObj,
        Health = healthObj,
        Distance = distanceObj,
        Tracer = tracer,
        Skeleton = skeleton,
    }

    -- Initialize properties only if objects exist
    if box then
        box.Visible = false
        box.Thickness = 2
        box.Filled = false
    end
    if nameObj then
        nameObj.Visible = false
        nameObj.Size = 14
        nameObj.Center = true
        nameObj.Outline = true
    end
    if healthObj then
        healthObj.Visible = false
        healthObj.Size = 12
        healthObj.Center = true
        healthObj.Outline = true
    end
    if distanceObj then
        distanceObj.Visible = false
        distanceObj.Size = 12
        distanceObj.Center = true
        distanceObj.Outline = true
    end
    if tracer then
        tracer.Visible = false
        tracer.Thickness = 1
    end
    -- skeleton lines already initialized with Visible = false
end

-- Get character height for box scaling
local function getCharacterHeight(character)
    local head = character:FindFirstChild("Head")
    local root = character:FindFirstChild("HumanoidRootPart")
    if head and root then
        return math.abs(head.Position.Y - root.Position.Y) * 2.2
    else
        return 5
    end
end

-- Main ESP update function with exhaustive nil checks
local function updateESP()
    if not Settings.Visuals.ESP.Enabled then
        -- Hide everything
        for _, objs in pairs(ESPCache) do
            if objs then
                if objs.Box and objs.Box.Visible then objs.Box.Visible = false end
                if objs.Name and objs.Name.Visible then objs.Name.Visible = false end
                if objs.Health and objs.Health.Visible then objs.Health.Visible = false end
                if objs.Distance and objs.Distance.Visible then objs.Distance.Visible = false end
                if objs.Tracer and objs.Tracer.Visible then objs.Tracer.Visible = false end
                if objs.Skeleton then
                    for _, line in ipairs(objs.Skeleton) do
                        if line and line.Visible then line.Visible = false end
                    end
                end
            end
        end
        return
    end

    for player, objs in pairs(ESPCache) do
        -- Safety: if objs table is nil, skip
        if not objs then continue end

        -- If player is invalid, clean up
        if not player or not player.Parent then
            cleanESP(player)
            continue
        end

        local char = player.Character
        if not char then
            -- Hide ESP for this player
            if objs.Box and objs.Box.Visible then objs.Box.Visible = false end
            if objs.Name and objs.Name.Visible then objs.Name.Visible = false end
            if objs.Health and objs.Health.Visible then objs.Health.Visible = false end
            if objs.Distance and objs.Distance.Visible then objs.Distance.Visible = false end
            if objs.Tracer and objs.Tracer.Visible then objs.Tracer.Visible = false end
            if objs.Skeleton then
                for _, line in ipairs(objs.Skeleton) do
                    if line and line.Visible then line.Visible = false end
                end
            end
            continue
        end

        local root = char:FindFirstChild("HumanoidRootPart")
        local humanoid = char:FindFirstChild("Humanoid")
        if not root or not humanoid or humanoid.Health <= 0 then
            -- Character invalid, hide ESP
            if objs.Box and objs.Box.Visible then objs.Box.Visible = false end
            if objs.Name and objs.Name.Visible then objs.Name.Visible = false end
            if objs.Health and objs.Health.Visible then objs.Health.Visible = false end
            if objs.Distance and objs.Distance.Visible then objs.Distance.Visible = false end
            if objs.Tracer and objs.Tracer.Visible then objs.Tracer.Visible = false end
            if objs.Skeleton then
                for _, line in ipairs(objs.Skeleton) do
                    if line and line.Visible then line.Visible = false end
                end
            end
            continue
        end

        if not IsEnemy(player) then
            if objs.Box and objs.Box.Visible then objs.Box.Visible = false end
            if objs.Name and objs.Name.Visible then objs.Name.Visible = false end
            if objs.Health and objs.Health.Visible then objs.Health.Visible = false end
            if objs.Distance and objs.Distance.Visible then objs.Distance.Visible = false end
            if objs.Tracer and objs.Tracer.Visible then objs.Tracer.Visible = false end
            if objs.Skeleton then
                for _, line in ipairs(objs.Skeleton) do
                    if line and line.Visible then line.Visible = false end
                end
            end
            continue
        end

        local screenPos, onScreen = Camera:WorldToViewportPoint(root.Position)
        if not onScreen or screenPos.Z <= 0 then
            if objs.Box and objs.Box.Visible then objs.Box.Visible = false end
            if objs.Name and objs.Name.Visible then objs.Name.Visible = false end
            if objs.Health and objs.Health.Visible then objs.Health.Visible = false end
            if objs.Distance and objs.Distance.Visible then objs.Distance.Visible = false end
            if objs.Tracer and objs.Tracer.Visible then objs.Tracer.Visible = false end
            if objs.Skeleton then
                for _, line in ipairs(objs.Skeleton) do
                    if line and line.Visible then line.Visible = false end
                end
            end
            continue
        end

        local dist = (Camera.CFrame.Position - root.Position).Magnitude
        local charHeight = getCharacterHeight(char)
        local scale = 500 / math.max(dist, 1)
        local boxHeight = charHeight * scale
        local boxWidth = boxHeight * 0.6
        boxHeight = math.clamp(boxHeight, 20, 200)
        boxWidth = math.clamp(boxWidth, 15, 150)
        local boxX = screenPos.X - boxWidth/2
        local boxY = screenPos.Y - boxHeight/2

        -- Box (only if object exists)
        if Settings.Visuals.ESP.Box and objs.Box then
            objs.Box.Visible = true
            objs.Box.Color = hexToColor3(Settings.Visuals.ESP.BoxColor)
            objs.Box.Position = Vector2.new(boxX, boxY)
            objs.Box.Size = Vector2.new(boxWidth, boxHeight)
        elseif objs.Box and objs.Box.Visible then
            objs.Box.Visible = false
        end

        -- Name
        if Settings.Visuals.ESP.Name and objs.Name then
            objs.Name.Visible = true
            objs.Name.Color = hexToColor3(Settings.Visuals.ESP.NameColor)
            objs.Name.Position = Vector2.new(screenPos.X, boxY - 18)
            objs.Name.Text = player.Name
        elseif objs.Name and objs.Name.Visible then
            objs.Name.Visible = false
        end

        -- Health
        if Settings.Visuals.ESP.Health and objs.Health then
            objs.Health.Visible = true
            objs.Health.Color = hexToColor3(Settings.Visuals.ESP.HealthColor)
            objs.Health.Position = Vector2.new(screenPos.X, boxY + boxHeight + 5)
            objs.Health.Text = math.floor(humanoid.Health) .. " HP"
        elseif objs.Health and objs.Health.Visible then
            objs.Health.Visible = false
        end

        -- Distance
        if Settings.Visuals.ESP.Distance and objs.Distance then
            objs.Distance.Visible = true
            objs.Distance.Color = hexToColor3(Settings.Visuals.ESP.DistanceColor)
            objs.Distance.Position = Vector2.new(screenPos.X, boxY + boxHeight + 20)
            objs.Distance.Text = math.floor(dist) .. " studs"
        elseif objs.Distance and objs.Distance.Visible then
            objs.Distance.Visible = false
        end

        -- Tracer
        if Settings.Visuals.ESP.Tracer and objs.Tracer then
            objs.Tracer.Visible = true
            objs.Tracer.Color = hexToColor3(Settings.Visuals.ESP.TracerColor)
            local origin = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
            objs.Tracer.From = origin
            objs.Tracer.To = Vector2.new(screenPos.X, screenPos.Y)
        elseif objs.Tracer and objs.Tracer.Visible then
            objs.Tracer.Visible = false
        end

        -- Skeleton
        if Settings.Visuals.ESP.Skeleton and objs.Skeleton then
            local joints = getJoints(char)
            local humanoidRig = humanoid and humanoid.RigType
            local connections = nil
            if humanoidRig == Enum.HumanoidRigType.R15 then
                connections = skeletonConnections.R15
            elseif humanoidRig == Enum.HumanoidRigType.R6 then
                connections = skeletonConnections.R6
            end

            if connections then
                local skeletonColor = hexToColor3(Settings.Visuals.ESP.SkeletonColor)
                for i, conn in ipairs(connections) do
                    local partA = joints[conn[1]]
                    local partB = joints[conn[2]]
                    if partA and partB then
                        local posA, visA = Camera:WorldToViewportPoint(partA.Position)
                        local posB, visB = Camera:WorldToViewportPoint(partB.Position)
                        if visA and visB and posA.Z > 0 and posB.Z > 0 then
                            local line = objs.Skeleton[i]
                            if line then
                                line.Visible = true
                                line.Color = skeletonColor
                                line.From = Vector2.new(posA.X, posA.Y)
                                line.To = Vector2.new(posB.X, posB.Y)
                            end
                        else
                            local line = objs.Skeleton[i]
                            if line and line.Visible then line.Visible = false end
                        end
                    else
                        local line = objs.Skeleton[i]
                        if line and line.Visible then line.Visible = false end
                    end
                end
                -- Hide any extra skeleton lines beyond connection count
                for i = #connections + 1, #objs.Skeleton do
                    local line = objs.Skeleton[i]
                    if line and line.Visible then line.Visible = false end
                end
            else
                -- No connections (rig type unknown), hide all skeleton lines
                for _, line in ipairs(objs.Skeleton) do
                    if line and line.Visible then line.Visible = false end
                end
            end
        elseif objs.Skeleton then
            for _, line in ipairs(objs.Skeleton) do
                if line and line.Visible then line.Visible = false end
            end
        end
    end
end

-- Initialize ESP for existing players
for _, player in pairs(Players:GetPlayers()) do
    createESP(player)
end

-- Handle new players
Players.PlayerAdded:Connect(function(player)
    createESP(player)
end)

Players.PlayerRemoving:Connect(function(player)
    cleanESP(player)
end)

RunService.RenderStepped:Connect(updateESP)

notif:Notify("Aqua.lol loaded take care! Press RightAlt to toggle UI.", 5, "success", function() end)
print("Aqua is him?")
