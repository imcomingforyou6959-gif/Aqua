--[[
    Universal Advanced Script - Integrated with UI Library
    Features:
    - Aimbot (Camera & CFrame modes) with smoothness, prediction, resolver
    - Client-sided ESP (Box, Name, Health, Distance, Tracer, Tool)
    - FOV circle
    - ESP clearing to prevent ghosting
    - Auto-prediction and resolver
    - Config saving/loading via library
]]

-- Load your UI library (provided)
if Library then Library:Unload() end

local LoadTick = os.clock()

local Library do
    -- (paste your entire library code here, or require it)
    -- For brevity, we assume the library is loaded from the provided code.
    -- In actual usage, the library code would be present.
end

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Stats = game:GetService("Stats")
local Workspace = game:GetService("Workspace")

-- ============ UTILITY FUNCTIONS ============
local function GetPing()
    return Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
end

local function Clamp(value, min, max)
    return math.max(min, math.min(max, value))
end

-- ============ SETTINGS TABLE ============
local Settings = {
    Aimbot = {
        Enabled = false,
        Mode = "Camera",          -- "Camera" or "CFrame"
        Smoothness = 0.5,
        FOV = 90,
        ShowFOV = true,
        FOVColor = Color3.fromRGB(255, 255, 255),
        FOVAlpha = 0.5,
        TeamCheck = true,
        VisibleCheck = true,
        TargetPart = "Head",      -- Head, HumanoidRootPart, UpperTorso, LowerTorso
        Prediction = 0.1,
        AutoPrediction = true,
        Resolver = true,
        ResolverMode = "Average", -- Average, Smart, Bruteforce
        ResolverHistory = 10,
        Keybind = Enum.UserInputType.MouseButton2,
        LockMode = "Hold",        -- Hold, Toggle
        Locked = false,
        LastKeyState = false,
    },
    ESP = {
        Enabled = false,
        MaxDistance = 1000,
        RefreshRate = 0.03,
        TeamCheck = true,
        VisibilityCheck = false,
        Box = {
            Enabled = true,
            Color = Color3.fromRGB(255, 0, 0),
            Outline = true,
            OutlineColor = Color3.fromRGB(0, 0, 0),
            Fill = false,
            FillTransparency = 0.7,
        },
        Name = {
            Enabled = true,
            Color = Color3.fromRGB(255, 255, 255),
            Size = 16,
            Outline = true,
        },
        Health = {
            Enabled = true,
            Bar = true,
            Text = true,
            BarWidth = 4,
            ColorMode = "Gradient", -- Gradient, Static
        },
        Distance = {
            Enabled = true,
            Color = Color3.fromRGB(255, 255, 255),
        },
        Tracer = {
            Enabled = false,
            Color = Color3.fromRGB(255, 255, 255),
            Origin = "Bottom",       -- Bottom, Top, Center, Mouse
            Thickness = 1,
        },
        Tool = {
            Enabled = true,
            Color = Color3.fromRGB(255, 255, 0),
        },
    },
    Misc = {
        Walkspeed = {
            Enabled = false,
            Value = 16,
        },
        JumpPower = {
            Enabled = false,
            Value = 50,
        },
    },
}

-- ============ UI CONSTRUCTION ============
local Window = Library:Window({
    Name = "Universal Advanced",
    Logo = "",                     -- optional logo asset ID
    FadeTime = 0.4,
    Size = UDim2.new(0, 800, 0, 600)
})

local Watermark = Library:Watermark("Universal Advanced")
local KeybindList = Library:KeybindList()

-- Create pages
local AimbotPage = Window:Page({ Name = "Aimbot", Columns = 2 })
local ESPPage = Window:Page({ Name = "ESP", Columns = 2 })
local MiscPage = Window:Page({ Name = "Misc", Columns = 2 })
local SettingsPage = Library:CreateSettingsPage(Window, Watermark, KeybindList)

-- ============ AIMBOT PAGE ============
-- Section 1: Main Settings
local AimbotMain = AimbotPage:Section({ Name = "Main", Side = 1 })

AimbotMain:Toggle({
    Name = "Enable Aimbot",
    Flag = "AimbotEnabled",
    Default = false,
    Callback = function(v) Settings.Aimbot.Enabled = v end
})

AimbotMain:Dropdown({
    Name = "Aimbot Mode",
    Flag = "AimbotMode",
    Items = { "Camera", "CFrame" },
    Default = "Camera",
    Callback = function(v) Settings.Aimbot.Mode = v end
})

AimbotMain:Slider({
    Name = "Smoothness",
    Flag = "AimbotSmoothness",
    Min = 0.1, Max = 1, Decimals = 0.01,
    Default = 0.5,
    Callback = function(v) Settings.Aimbot.Smoothness = v end
})

AimbotMain:Slider({
    Name = "FOV Size",
    Flag = "AimbotFOV",
    Min = 10, Max = 360, Decimals = 0,
    Default = 90,
    Callback = function(v) Settings.Aimbot.FOV = v end
})

AimbotMain:Toggle({
    Name = "Show FOV Circle",
    Flag = "AimbotShowFOV",
    Default = true,
    Callback = function(v) Settings.Aimbot.ShowFOV = v end
})

AimbotMain:Label("FOV Color"):Colorpicker({
    Flag = "AimbotFOVColor",
    Default = Color3.fromRGB(255, 255, 255),
    Alpha = 0.5,
    Callback = function(c, a)
        Settings.Aimbot.FOVColor = c
        Settings.Aimbot.FOVAlpha = a
    end
})

AimbotMain:Label("Aimbot Key"):Keybind({
    Name = "Aimbot Key",
    Flag = "AimbotKey",
    Default = Enum.UserInputType.MouseButton2,
    Mode = "Hold",
    Callback = function(key, mode)
        Settings.Aimbot.Keybind = key
        Settings.Aimbot.LockMode = mode
    end
})

-- Section 2: Target Settings
local AimbotTarget = AimbotPage:Section({ Name = "Target", Side = 2 })

AimbotTarget:Toggle({
    Name = "Team Check",
    Flag = "AimbotTeamCheck",
    Default = true,
    Callback = function(v) Settings.Aimbot.TeamCheck = v end
})

AimbotTarget:Toggle({
    Name = "Visible Check",
    Flag = "AimbotVisibleCheck",
    Default = true,
    Callback = function(v) Settings.Aimbot.VisibleCheck = v end
})

AimbotTarget:Dropdown({
    Name = "Target Part",
    Flag = "AimbotTargetPart",
    Items = { "Head", "HumanoidRootPart", "UpperTorso", "LowerTorso" },
    Default = "Head",
    Multi = false,
    Callback = function(v) Settings.Aimbot.TargetPart = v end
})

AimbotTarget:Slider({
    Name = "Prediction",
    Flag = "AimbotPrediction",
    Min = 0, Max = 0.5, Decimals = 0.01,
    Default = 0.1,
    Callback = function(v) Settings.Aimbot.Prediction = v end
})

AimbotTarget:Toggle({
    Name = "Auto Prediction",
    Flag = "AimbotAutoPrediction",
    Default = true,
    Callback = function(v) Settings.Aimbot.AutoPrediction = v end
})

-- Resolver settings
AimbotTarget:Toggle({
    Name = "Enable Resolver",
    Flag = "AimbotResolver",
    Default = true,
    Callback = function(v) Settings.Aimbot.Resolver = v end
})

AimbotTarget:Dropdown({
    Name = "Resolver Mode",
    Flag = "AimbotResolverMode",
    Items = { "Average", "Smart", "Bruteforce" },
    Default = "Average",
    Callback = function(v) Settings.Aimbot.ResolverMode = v end
})

AimbotTarget:Slider({
    Name = "Resolver History",
    Flag = "AimbotResolverHistory",
    Min = 5, Max = 20, Decimals = 0,
    Default = 10,
    Callback = function(v) Settings.Aimbot.ResolverHistory = v end
})

-- ============ ESP PAGE ============
-- Section 1: ESP Settings
local ESPMain = ESPPage:Section({ Name = "ESP Settings", Side = 1 })

ESPMain:Toggle({
    Name = "Enable ESP",
    Flag = "ESPEnabled",
    Default = false,
    Callback = function(v) Settings.ESP.Enabled = v end
})

ESPMain:Slider({
    Name = "Max Distance",
    Flag = "ESPMaxDistance",
    Min = 100, Max = 5000, Decimals = 0,
    Default = 1000,
    Callback = function(v) Settings.ESP.MaxDistance = v end
})

ESPMain:Slider({
    Name = "Refresh Rate (s)",
    Flag = "ESPRefreshRate",
    Min = 0.01, Max = 0.1, Decimals = 0.01,
    Default = 0.03,
    Callback = function(v) Settings.ESP.RefreshRate = v end
})

ESPMain:Toggle({
    Name = "Team Check",
    Flag = "ESPTeamCheck",
    Default = true,
    Callback = function(v) Settings.ESP.TeamCheck = v end
})

ESPMain:Toggle({
    Name = "Visibility Check",
    Flag = "ESPVisibilityCheck",
    Default = false,
    Callback = function(v) Settings.ESP.VisibilityCheck = v end
})

-- Box settings
local ESPBox = ESPPage:Section({ Name = "Box", Side = 2 })

ESPBox:Toggle({
    Name = "Boxes",
    Flag = "ESPBoxEnabled",
    Default = true,
    Callback = function(v) Settings.ESP.Box.Enabled = v end
})

ESPBox:Label("Box Color"):Colorpicker({
    Flag = "ESPBoxColor",
    Default = Color3.fromRGB(255, 0, 0),
    Callback = function(c) Settings.ESP.Box.Color = c end
})

ESPBox:Toggle({
    Name = "Outline",
    Flag = "ESPBoxOutline",
    Default = true,
    Callback = function(v) Settings.ESP.Box.Outline = v end
})

ESPBox:Label("Outline Color"):Colorpicker({
    Flag = "ESPBoxOutlineColor",
    Default = Color3.fromRGB(0, 0, 0),
    Callback = function(c) Settings.ESP.Box.OutlineColor = c end
})

ESPBox:Toggle({
    Name = "Fill",
    Flag = "ESPBoxFill",
    Default = false,
    Callback = function(v) Settings.ESP.Box.Fill = v end
})

ESPBox:Slider({
    Name = "Fill Transparency",
    Flag = "ESPBoxFillTransparency",
    Min = 0, Max = 1, Decimals = 0.1,
    Default = 0.7,
    Callback = function(v) Settings.ESP.Box.FillTransparency = v end
})

-- Name settings
local ESPName = ESPPage:Section({ Name = "Name", Side = 2 })

ESPName:Toggle({
    Name = "Names",
    Flag = "ESPNameEnabled",
    Default = true,
    Callback = function(v) Settings.ESP.Name.Enabled = v end
})

ESPName:Label("Name Color"):Colorpicker({
    Flag = "ESPNameColor",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(c) Settings.ESP.Name.Color = c end
})

ESPName:Slider({
    Name = "Name Size",
    Flag = "ESPNameSize",
    Min = 10, Max = 30, Decimals = 0,
    Default = 16,
    Callback = function(v) Settings.ESP.Name.Size = v end
})

ESPName:Toggle({
    Name = "Outline",
    Flag = "ESPNameOutline",
    Default = true,
    Callback = function(v) Settings.ESP.Name.Outline = v end
})

-- Health settings
local ESPHealth = ESPPage:Section({ Name = "Health", Side = 1 })

ESPHealth:Toggle({
    Name = "Health Bar",
    Flag = "ESPHealthBar",
    Default = true,
    Callback = function(v) Settings.ESP.Health.Bar = v end
})

ESPHealth:Toggle({
    Name = "Health Text",
    Flag = "ESPHealthText",
    Default = true,
    Callback = function(v) Settings.ESP.Health.Text = v end
})

ESPHealth:Slider({
    Name = "Bar Width",
    Flag = "ESPHealthBarWidth",
    Min = 2, Max = 10, Decimals = 0,
    Default = 4,
    Callback = function(v) Settings.ESP.Health.BarWidth = v end
})

ESPHealth:Dropdown({
    Name = "Color Mode",
    Flag = "ESPHealthColorMode",
    Items = { "Gradient", "Static" },
    Default = "Gradient",
    Callback = function(v) Settings.ESP.Health.ColorMode = v end
})

-- Distance settings
local ESPDistance = ESPPage:Section({ Name = "Distance", Side = 1 })

ESPDistance:Toggle({
    Name = "Distance",
    Flag = "ESPDistanceEnabled",
    Default = true,
    Callback = function(v) Settings.ESP.Distance.Enabled = v end
})

ESPDistance:Label("Distance Color"):Colorpicker({
    Flag = "ESPDistanceColor",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(c) Settings.ESP.Distance.Color = c end
})

-- Tracer settings
local ESPTracer = ESPPage:Section({ Name = "Tracer", Side = 2 })

ESPTracer:Toggle({
    Name = "Tracers",
    Flag = "ESPTracerEnabled",
    Default = false,
    Callback = function(v) Settings.ESP.Tracer.Enabled = v end
})

ESPTracer:Label("Tracer Color"):Colorpicker({
    Flag = "ESPTracerColor",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(c) Settings.ESP.Tracer.Color = c end
})

ESPTracer:Dropdown({
    Name = "Origin",
    Flag = "ESPTracerOrigin",
    Items = { "Bottom", "Top", "Center", "Mouse" },
    Default = "Bottom",
    Callback = function(v) Settings.ESP.Tracer.Origin = v end
})

ESPTracer:Slider({
    Name = "Thickness",
    Flag = "ESPTracerThickness",
    Min = 1, Max = 3, Decimals = 0,
    Default = 1,
    Callback = function(v) Settings.ESP.Tracer.Thickness = v end
})

-- Tool ESP
local ESPTool = ESPPage:Section({ Name = "Tool ESP", Side = 1 })

ESPTool:Toggle({
    Name = "Show Tool",
    Flag = "ESPToolEnabled",
    Default = true,
    Callback = function(v) Settings.ESP.Tool.Enabled = v end
})

ESPTool:Label("Tool Color"):Colorpicker({
    Flag = "ESPToolColor",
    Default = Color3.fromRGB(255, 255, 0),
    Callback = function(c) Settings.ESP.Tool.Color = c end
})

-- ============ MISC PAGE ============
local MiscSection = MiscPage:Section({ Name = "Movement", Side = 1 })

MiscSection:Toggle({
    Name = "Walkspeed",
    Flag = "MiscWalkspeedEnabled",
    Default = false,
    Callback = function(v) Settings.Misc.Walkspeed.Enabled = v end
})

MiscSection:Slider({
    Name = "Walkspeed Value",
    Flag = "MiscWalkspeed",
    Min = 16, Max = 200, Decimals = 0,
    Default = 16,
    Callback = function(v)
        Settings.Misc.Walkspeed.Value = v
        if Settings.Misc.Walkspeed.Enabled and LocalPlayer.Character then
            local hum = LocalPlayer.Character:FindFirstChild("Humanoid")
            if hum then hum.WalkSpeed = v end
        end
    end
})

MiscSection:Toggle({
    Name = "Jump Power",
    Flag = "MiscJumpEnabled",
    Default = false,
    Callback = function(v) Settings.Misc.JumpPower.Enabled = v end
})

MiscSection:Slider({
    Name = "Jump Power Value",
    Flag = "MiscJumpPower",
    Min = 50, Max = 200, Decimals = 0,
    Default = 50,
    Callback = function(v)
        Settings.Misc.JumpPower.Value = v
        if Settings.Misc.JumpPower.Enabled and LocalPlayer.Character then
            local hum = LocalPlayer.Character:FindFirstChild("Humanoid")
            if hum then hum.JumpPower = v end
        end
    end
})

-- ============ ADVANCED AIMBOT LOGIC ============

-- Target data storage for resolver
local TargetData = {}
local ResolverCache = {}

-- Get target part from character
local function GetTargetPart(character)
    if not character then return nil end
    local part = character:FindFirstChild(Settings.Aimbot.TargetPart)
    if not part then
        -- fallbacks
        part = character:FindFirstChild("Head")
            or character:FindFirstChild("HumanoidRootPart")
            or character:FindFirstChild("Torso")
    end
    return part
end

-- Check if target is visible (raycast)
local function IsVisible(from, targetPart)
    local direction = targetPart.Position - from
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
    local result = workspace:Raycast(from, direction, rayParams)
    return not result or result.Instance:IsDescendantOf(targetPart.Parent)
end

-- Team check
local function IsEnemy(player)
    if player == LocalPlayer then return false end
    if not Settings.Aimbot.TeamCheck then return true end
    if player.TeamColor and LocalPlayer.TeamColor then
        return player.TeamColor ~= LocalPlayer.TeamColor
    end
    if player.Team and LocalPlayer.Team then
        return player.Team ~= LocalPlayer.Team
    end
    return true
end

-- Update velocity history for prediction
local function UpdateVelocityHistory()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local root = player.Character:FindFirstChild("HumanoidRootPart")
            if root then
                if not TargetData[player] then
                    TargetData[player] = { positions = {}, velocities = {} }
                end
                local data = TargetData[player]
                table.insert(data.positions, { pos = root.Position, time = tick() })
                if #data.positions > Settings.Aimbot.ResolverHistory then
                    table.remove(data.positions, 1)
                end
                if #data.positions >= 2 then
                    local p1 = data.positions[#data.positions-1]
                    local p2 = data.positions[#data.positions]
                    local dt = p2.time - p1.time
                    if dt > 0 then
                        local vel = (p2.pos - p1.pos) / dt
                        table.insert(data.velocities, vel)
                        if #data.velocities > Settings.Aimbot.ResolverHistory then
                            table.remove(data.velocities, 1)
                        end
                    end
                end
            end
        end
    end
end

-- Prediction calculation
local function GetPredictedPosition(part, player)
    local basePos = part.Position
    local velocity = part.Velocity
    local predAmount = Settings.Aimbot.Prediction

    if Settings.Aimbot.AutoPrediction then
        local speed = velocity.Magnitude
        if speed > 5 and speed < 200 then
            predAmount = predAmount * (speed / 50) -- scale with speed
        end
    end

    local ping = GetPing()
    return basePos + velocity * (ping + predAmount)
end

-- Resolver: choose target part based on history
local function ResolveTarget(player)
    if not Settings.Aimbot.Resolver or not player.Character then
        return GetTargetPart(player.Character)
    end
    local data = TargetData[player]
    if not data or #data.positions < 3 then
        return GetTargetPart(player.Character)
    end

    local mode = Settings.Aimbot.ResolverMode
    if mode == "Average" then
        -- average of last few positions
        local sum = Vector3.new()
        local count = math.min(3, #data.positions)
        for i = #data.positions - count + 1, #data.positions do
            sum = sum + data.positions[i].pos
        end
        local avgPos = sum / count
        -- find part closest to average
        local closest, bestPart = math.huge, nil
        for _, name in ipairs({"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"}) do
            local p = player.Character:FindFirstChild(name)
            if p then
                local dist = (p.Position - avgPos).Magnitude
                if dist < closest then
                    closest = dist
                    bestPart = p
                end
            end
        end
        return bestPart or GetTargetPart(player.Character)
    elseif mode == "Smart" then
        -- detect jitter: variance in positions
        if #data.positions >= 5 then
            local last = data.positions[#data.positions].pos
            local prev = data.positions[#data.positions-2].pos
            local variance = (last - prev).Magnitude / 2
            if variance > 10 then
                -- jittering, aim center mass
                return player.Character:FindFirstChild("HumanoidRootPart") or GetTargetPart(player.Character)
            end
        end
        return GetTargetPart(player.Character)
    elseif mode == "Bruteforce" then
        local parts = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"}
        local idx = (ResolverCache[player] or 0) + 1
        if idx > #parts then idx = 1 end
        ResolverCache[player] = idx
        return player.Character:FindFirstChild(parts[idx]) or GetTargetPart(player.Character)
    end
    return GetTargetPart(player.Character)
end

-- Find closest target in FOV
local function GetClosestTarget()
    if not Settings.Aimbot.Enabled then return nil end
    local closestPlayer, closestDist = nil, Settings.Aimbot.FOV
    local screenCenter = Camera.ViewportSize / 2

    for _, player in pairs(Players:GetPlayers()) do
        if not IsEnemy(player) then continue end
        if not player.Character then continue end

        local targetPart = ResolveTarget(player)
        if not targetPart then continue end

        local targetPos = GetPredictedPosition(targetPart, player)
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
        if not onScreen then continue end

        local dist = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
        if dist > Settings.Aimbot.FOV then continue end

        if Settings.Aimbot.VisibleCheck and not IsVisible(Camera.CFrame.Position, targetPart) then
            continue
        end

        if dist < closestDist then
            closestDist = dist
            closestPlayer = player
        end
    end
    return closestPlayer
end

-- Key state handling
local function IsKeyPressed(key)
    if typeof(key) == "EnumItem" then
        if key.Name:find("MouseButton") then
            return UserInputService:IsMouseButtonPressed(key)
        else
            return UserInputService:IsKeyDown(key)
        end
    elseif typeof(key) == "string" then
        for _, e in pairs(Enum.KeyCode:GetEnumItems()) do
            if e.Name == key then
                return UserInputService:IsKeyDown(e)
            end
        end
        for _, e in pairs(Enum.UserInputType:GetEnumItems()) do
            if e.Name == key then
                if e == Enum.UserInputType.MouseButton1 then
                    return UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
                elseif e == Enum.UserInputType.MouseButton2 then
                    return UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
                elseif e == Enum.UserInputType.MouseButton3 then
                    return UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton3)
                end
            end
        end
    end
    return false
end

-- Aimbot state update
local aimbotActive = false
local lastKeyState = false
local function UpdateAimbotState()
    if not Settings.Aimbot.Enabled then
        aimbotActive = false
        return
    end
    local keyPressed = IsKeyPressed(Settings.Aimbot.Keybind)
    if Settings.Aimbot.LockMode == "Hold" then
        aimbotActive = keyPressed
    else -- Toggle
        if keyPressed and not lastKeyState then
            aimbotActive = not aimbotActive
        end
        lastKeyState = keyPressed
    end
end

-- Apply aimbot
local function ApplyAimbot()
    if not aimbotActive then return end
    local targetPlayer = GetClosestTarget()
    if not targetPlayer or not targetPlayer.Character then return end
    local targetPart = ResolveTarget(targetPlayer)
    if not targetPart then return end
    local targetPos = GetPredictedPosition(targetPart, targetPlayer)

    if Settings.Aimbot.Mode == "Camera" then
        -- Camera lock
        local currentLook = Camera.CFrame.LookVector
        local targetLook = (targetPos - Camera.CFrame.Position).Unit
        local smooth = Settings.Aimbot.Smoothness
        local newLook = currentLook:Lerp(targetLook, smooth)
        Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, Camera.CFrame.Position + newLook)
    else -- CFrame mode (teleports character rotation)
        local char = LocalPlayer.Character
        if char then
            local root = char:FindFirstChild("HumanoidRootPart")
            if root then
                local dir = (targetPos - root.Position).Unit
                root.CFrame = CFrame.lookAt(root.Position, root.Position + dir)
            end
        end
    end
end

-- ============ ESP SYSTEM ============
local ESPCache = {}
local lastESPUpdate = 0

local function CleanESP(player)
    if ESPCache[player] then
        for _, obj in pairs(ESPCache[player]) do
            if obj.Remove then
                pcall(function() obj:Remove() end)
            end
        end
        ESPCache[player] = nil
    end
end

local function CleanAllESP()
    for player, _ in pairs(ESPCache) do
        CleanESP(player)
    end
end

local function CreateESP(player)
    if player == LocalPlayer then return end
    ESPCache[player] = {
        Box = Drawing.new("Square"),
        BoxOutline = Drawing.new("Square"),
        Name = Drawing.new("Text"),
        HealthBar = Drawing.new("Square"),
        HealthText = Drawing.new("Text"),
        Distance = Drawing.new("Text"),
        Tracer = Drawing.new("Line"),
        Tool = Drawing.new("Text"),
    }
    for _, obj in pairs(ESPCache[player]) do
        obj.Visible = false
    end
    -- Initialize properties
    ESPCache[player].Box.Thickness = 2
    ESPCache[player].Box.Filled = Settings.ESP.Box.Fill
    ESPCache[player].Box.Transparency = Settings.ESP.Box.Fill and Settings.ESP.Box.FillTransparency or 1
    ESPCache[player].BoxOutline.Thickness = 4
    ESPCache[player].BoxOutline.Filled = false
    ESPCache[player].Name.Size = Settings.ESP.Name.Size
    ESPCache[player].Name.Center = true
    ESPCache[player].Name.Outline = Settings.ESP.Name.Outline
    ESPCache[player].HealthBar.Filled = true
    ESPCache[player].HealthBar.Thickness = 1
    ESPCache[player].HealthText.Size = 12
    ESPCache[player].HealthText.Center = true
    ESPCache[player].HealthText.Outline = true
    ESPCache[player].Distance.Size = 12
    ESPCache[player].Distance.Center = true
    ESPCache[player].Distance.Outline = true
    ESPCache[player].Tracer.Thickness = Settings.ESP.Tracer.Thickness
    ESPCache[player].Tool.Size = 12
    ESPCache[player].Tool.Center = true
    ESPCache[player].Tool.Outline = true
end

local function GetCharacterBounds(character)
    local hum = character:FindFirstChild("Humanoid")
    local root = character:FindFirstChild("HumanoidRootPart")
    local head = character:FindFirstChild("Head")
    if not root or not hum then return nil end
    local height = 5
    if head then
        height = (head.Position.Y - root.Position.Y) * 2.2
    else
        height = hum.Height * 1.5
    end
    return {
        Position = root.Position,
        Height = math.max(height, 3),
        Width = math.max(height * 0.6, 2)
    }
end

local function UpdateESP()
    if not Settings.ESP.Enabled then
        CleanAllESP()
        return
    end
    if tick() - lastESPUpdate < Settings.ESP.RefreshRate then return end
    lastESPUpdate = tick()

    local screenCenter = Camera.ViewportSize / 2

    for player, objs in pairs(ESPCache) do
        if not player or not player.Character then
            CleanESP(player)
            continue
        end
        local char = player.Character
        local hum = char:FindFirstChild("Humanoid")
        local root = char:FindFirstChild("HumanoidRootPart")
        if not hum or not root or hum.Health <= 0 then
            CleanESP(player)
            continue
        end

        if Settings.ESP.TeamCheck and not IsEnemy(player) then
            for _, o in pairs(objs) do o.Visible = false end
            continue
        end

        local worldDist = (Camera.CFrame.Position - root.Position).Magnitude
        if worldDist > Settings.ESP.MaxDistance then
            for _, o in pairs(objs) do o.Visible = false end
            continue
        end

        local bounds = GetCharacterBounds(char)
        if not bounds then
            for _, o in pairs(objs) do o.Visible = false end
            continue
        end

        local screenPos, onScreen = Camera:WorldToViewportPoint(bounds.Position)
        if not onScreen then
            for _, o in pairs(objs) do o.Visible = false end
            continue
        end

        if Settings.ESP.VisibilityCheck and not IsVisible(Camera.CFrame.Position, root) then
            for _, o in pairs(objs) do o.Visible = false end
            continue
        end

        -- Scale box
        local scale = 500 / worldDist
        local boxH = bounds.Height * scale
        local boxW = bounds.Width * scale
        boxH = Clamp(boxH, 20, 200)
        boxW = Clamp(boxW, 15, 150)

        local boxX = screenPos.X - boxW/2
        local boxY = screenPos.Y - boxH/2

        -- Update colors
        objs.Box.Color = Settings.ESP.Box.Color
        objs.BoxOutline.Color = Settings.ESP.Box.OutlineColor
        objs.Name.Color = Settings.ESP.Name.Color
        objs.Distance.Color = Settings.ESP.Distance.Color
        objs.Tracer.Color = Settings.ESP.Tracer.Color
        objs.Tool.Color = Settings.ESP.Tool.Color

        -- Box
        if Settings.ESP.Box.Enabled then
            objs.Box.Visible = true
            objs.Box.Position = Vector2.new(boxX, boxY)
            objs.Box.Size = Vector2.new(boxW, boxH)
            objs.Box.Transparency = Settings.ESP.Box.Fill and Settings.ESP.Box.FillTransparency or 1
            if Settings.ESP.Box.Outline then
                objs.BoxOutline.Visible = true
                objs.BoxOutline.Position = Vector2.new(boxX-1, boxY-1)
                objs.BoxOutline.Size = Vector2.new(boxW+2, boxH+2)
            else
                objs.BoxOutline.Visible = false
            end
        else
            objs.Box.Visible = false
            objs.BoxOutline.Visible = false
        end

        -- Name
        if Settings.ESP.Name.Enabled then
            objs.Name.Visible = true
            objs.Name.Position = Vector2.new(screenPos.X, boxY - 20)
            objs.Name.Text = player.Name
            objs.Name.Size = Settings.ESP.Name.Size
        else
            objs.Name.Visible = false
        end

        -- Health
        if Settings.ESP.Health.Bar or Settings.ESP.Health.Text then
            local healthPercent = hum.Health / hum.MaxHealth
            local barColor = Settings.ESP.Health.ColorMode == "Gradient" and
                Color3.new(1 - healthPercent, healthPercent, 0) or Settings.ESP.Box.Color

            if Settings.ESP.Health.Bar then
                objs.HealthBar.Visible = true
                objs.HealthBar.Color = barColor
                objs.HealthBar.Size = Vector2.new(Settings.ESP.Health.BarWidth, boxH * healthPercent)
                objs.HealthBar.Position = Vector2.new(boxX - Settings.ESP.Health.BarWidth - 2, boxY + boxH - objs.HealthBar.Size.Y)
            else
                objs.HealthBar.Visible = false
            end

            if Settings.ESP.Health.Text then
                objs.HealthText.Visible = true
                objs.HealthText.Text = math.floor(hum.Health) .. "/" .. math.floor(hum.MaxHealth)
                objs.HealthText.Color = barColor
                objs.HealthText.Position = Vector2.new(boxX - 40, boxY + boxH/2)
            else
                objs.HealthText.Visible = false
            end
        else
            objs.HealthBar.Visible = false
            objs.HealthText.Visible = false
        end

        -- Distance
        if Settings.ESP.Distance.Enabled then
            objs.Distance.Visible = true
            objs.Distance.Position = Vector2.new(screenPos.X, boxY + boxH + 5)
            objs.Distance.Text = math.floor(worldDist) .. " studs"
        else
            objs.Distance.Visible = false
        end

        -- Tracer
        if Settings.ESP.Tracer.Enabled then
            objs.Tracer.Visible = true
            local origin
            if Settings.ESP.Tracer.Origin == "Bottom" then
                origin = Vector2.new(screenCenter.X, Camera.ViewportSize.Y)
            elseif Settings.ESP.Tracer.Origin == "Top" then
                origin = Vector2.new(screenCenter.X, 0)
            elseif Settings.ESP.Tracer.Origin == "Center" then
                origin = screenCenter
            else -- Mouse
                origin = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
            end
            objs.Tracer.From = origin
            objs.Tracer.To = Vector2.new(screenPos.X, screenPos.Y)
        else
            objs.Tracer.Visible = false
        end

        -- Tool
        if Settings.ESP.Tool.Enabled then
            local tool = char:FindFirstChildOfClass("Tool")
            if tool then
                objs.Tool.Visible = true
                objs.Tool.Text = "[" .. tool.Name .. "]"
                objs.Tool.Position = Vector2.new(screenPos.X, boxY + boxH + 20)
            else
                objs.Tool.Visible = false
            end
        else
            objs.Tool.Visible = false
        end
    end
end

-- ============ FOV CIRCLE ============
local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Thickness = 2
FOVCircle.NumSides = 60
FOVCircle.Filled = false

local function UpdateFOVCircle()
    if Settings.Aimbot.ShowFOV and Settings.Aimbot.Enabled then
        FOVCircle.Visible = true
        FOVCircle.Radius = Settings.Aimbot.FOV
        FOVCircle.Color = Settings.Aimbot.FOVColor
        FOVCircle.Transparency = Settings.Aimbot.FOVAlpha
        FOVCircle.Position = Camera.ViewportSize / 2
    else
        FOVCircle.Visible = false
    end
end

-- ============ MOVEMENT ============
local function UpdateMovement()
    if LocalPlayer.Character then
        local hum = LocalPlayer.Character:FindFirstChild("Humanoid")
        if hum then
            if Settings.Misc.Walkspeed.Enabled then
                hum.WalkSpeed = Settings.Misc.Walkspeed.Value
            end
            if Settings.Misc.JumpPower.Enabled then
                hum.JumpPower = Settings.Misc.JumpPower.Value
            end
        end
    end
end

-- ============ INITIALIZATION ============
for _, player in pairs(Players:GetPlayers()) do
    CreateESP(player)
end

Players.PlayerAdded:Connect(function(player)
    CreateESP(player)
end)

Players.PlayerRemoving:Connect(function(player)
    CleanESP(player)
    TargetData[player] = nil
    ResolverCache[player] = nil
end)

LocalPlayer.CharacterAdded:Connect(function(char)
    local hum = char:WaitForChild("Humanoid", 5)
    if Settings.Misc.Walkspeed.Enabled then
        hum.WalkSpeed = Settings.Misc.Walkspeed.Value
    end
    if Settings.Misc.JumpPower.Enabled then
        hum.JumpPower = Settings.Misc.JumpPower.Value
    end
end)

-- ============ MAIN LOOP ============
RunService.Heartbeat:Connect(UpdateVelocityHistory)

RunService.RenderStepped:Connect(function()
    UpdateFOVCircle()
    UpdateAimbotState()
    ApplyAimbot()
    UpdateESP()
    UpdateMovement()
end)

-- ============ CLEANUP ============
local OriginalUnload = Library.Unload
Library.Unload = function()
    FOVCircle:Remove()
    CleanAllESP()
    if OriginalUnload then
        OriginalUnload()
    end
end

Library:Notification("Success", "Universal Advanced Script Loaded!", 3)
print("Universal Advanced Script loaded successfully!")
